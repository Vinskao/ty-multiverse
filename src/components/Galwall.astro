---
import '../styles/galwall.css';
---
<div id="galwallWrapper">
  <div id="containerFront"></div>
  <div id="containerBack"></div>
</div>

<script>
  let frontList: string[] = [];
  let backList: string[] = [];
  const baseImagePath = import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/";

  // 檢查圖片是否存在
  async function checkImageExists(imagePath) {
    try {
      const response = await fetch(imagePath);
      return response.ok;
    } catch (error) {
      return false;
    }
  }

  // 獲取角色列表
  async function fetchCharacterList() {
    try {
      const token = localStorage.getItem('token');
      const headers: Record<string, string> = {
        "Content-Type": "application/json",
        "Accept": "application/json"
      };
      
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
      }
      
      const response = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/people/get-all`, {
        method: "POST",
        headers,
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error('Failed to fetch character list');
      }
      
      const data = await response.json();
      return data.map(char => char.name);
    } catch (error) {
      console.error('Error fetching character list:', error);
      return [];
    }
  }

  // 檢查三種圖片類型
  async function checkImageTypes(characterName) {
    const normalPath = `${baseImagePath}${characterName}.png`;
    const fightingPath = `${baseImagePath}${characterName}Fighting.png`;
    const ruinedPath = `${baseImagePath}${characterName}Ruined.png`;
    
    const [normalExists, fightingExists, ruinedExists] = await Promise.all([
      checkImageExists(normalPath),
      checkImageExists(fightingPath),
      checkImageExists(ruinedPath)
    ]);
    
    return {
      name: characterName,
      normalPath: normalExists ? normalPath : null,
      fightingPath: fightingExists ? fightingPath : null,
      ruinedPath: ruinedExists ? ruinedPath : null
    };
  }

  document.addEventListener("DOMContentLoaded", async function () {
    // 獲取角色列表
    const characterNames = await fetchCharacterList();
    
    // 檢查每個角色的圖片
    const imagePromises = characterNames.map(name => checkImageTypes(name));
    const imageResults = await Promise.all(imagePromises);
    
    // 收集所有有效的圖片路徑
    const validImages = imageResults.flatMap(result => {
      const paths: string[] = [];
      if (result.normalPath) paths.push(result.normalPath);
      if (result.fightingPath) paths.push(result.fightingPath);
      if (result.ruinedPath) paths.push(result.ruinedPath);
      return paths;
    });

    // 分配圖片到 front 和 back 列表
    const totalImages = validImages.length;
    const frontCount = Math.ceil(totalImages / 3);
    
    frontList = validImages.slice(0, frontCount);
    backList = validImages.slice(frontCount);

    // 初始化動畫
    const containerFront = document.getElementById("containerFront");
    const containerBack = document.getElementById("containerBack");

    function createAdDiv(imageURL, isFront) {
      const adDiv = document.createElement("div");
      adDiv.className = isFront ? "ad-front" : "ad-back";
      
      const adImage = document.createElement("img");
      adImage.className = "ad-image";
      adImage.src = imageURL;
      // 設置固定高度和寬度，保持比例
      adImage.style.height = "300px";
      adImage.style.width = "auto";
      adImage.style.objectFit = "contain";
      // 降低圖片渲染品質以提升效能
      adImage.style.imageRendering = "pixelated";
      adImage.style.imageRendering = "-webkit-optimize-contrast";
      adImage.style.imageRendering = "crisp-edges";
      
      // 圖片載入完成後進行品質優化
      adImage.onload = function() {
        optimizeImageQuality(adImage);
      };
      
      adDiv.appendChild(adImage);
      return adDiv;
    }

    // 圖片品質優化函數
    function optimizeImageQuality(imgElement) {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // 檢查 canvas context 是否成功獲取
        if (!ctx) {
          console.warn('無法獲取 canvas context');
          return;
        }
        
        // 設定較小的畫布尺寸來降低品質
        const targetWidth = 150; // 降低到一半尺寸
        const targetHeight = 275; // 降低到一半尺寸
        
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        
        // 設定較低的渲染品質
        ctx.imageSmoothingEnabled = false;
        ctx.imageSmoothingQuality = 'low';
        
        // 檢查原始圖片是否為 PNG（支持透明度）
        const originalSrc = imgElement.src;
        const isPNG = originalSrc.toLowerCase().includes('.png') || 
                     originalSrc.includes('data:image/png') ||
                     originalSrc.includes('image/png');
        
        // 繪製圖片到畫布
        ctx.drawImage(imgElement, 0, 0, targetWidth, targetHeight);
        
        // 根據原始格式選擇輸出格式
        let optimizedDataURL;
        if (isPNG) {
          // PNG 格式保持透明度
          optimizedDataURL = canvas.toDataURL('image/png');
        } else {
          // 其他格式使用 JPEG，但檢查是否有透明區域
          try {
            // 嘗試檢測是否有透明區域
            const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
            const hasTransparency = imageData.data.some((_, index) => 
              index % 4 === 3 && imageData.data[index] < 255
            );
            
            if (hasTransparency) {
              // 有透明區域，使用 PNG
              optimizedDataURL = canvas.toDataURL('image/png');
            } else {
              // 沒有透明區域，使用 JPEG
              optimizedDataURL = canvas.toDataURL('image/jpeg', 0.8);
            }
          } catch (e) {
            // 檢測失敗，安全起見使用 PNG
            optimizedDataURL = canvas.toDataURL('image/png');
          }
        }
        
        // 更新圖片來源
        imgElement.src = optimizedDataURL;
      } catch (error) {
        console.warn('圖片品質優化失敗:', error);
        // 如果優化失敗，保持原圖
      }
    }

    function loadAds(imageList, container, isFront) {
      container.innerHTML = "";
      const numAds = imageList.length;
      for (let i = 0; i < numAds; i++) {
        const imageURL = imageList[i];
        const adDiv = createAdDiv(imageURL, isFront);
        container.appendChild(adDiv);
      }
    }

    // 每 10 秒隨機重新排列圖片，並用 FLIP 動畫讓所有圖片平滑滑到新位置
    function animateContainer(container) {
      const SHUFFLE_INTERVAL = 40000; // 40 秒

      const doShuffle = () => {
        const items = Array.from(container.children) as HTMLElement[];
        if (items.length <= 1) return;

        // 1) 記錄初始位置（First）
        const firstPositions = new Map<HTMLElement, number>();
        items.forEach(el => {
          firstPositions.set(el, el.getBoundingClientRect().left);
        });

        // 2) 打亂順序（DOM 重新排序）
        const shuffled = [...items].sort(() => Math.random() - 0.5);
        shuffled.forEach(el => container.appendChild(el));

        // 3) 重新計算位置（Last）並設置 Invert → Play
        shuffled.forEach(el => {
          const lastLeft = el.getBoundingClientRect().left;
          const firstLeft = firstPositions.get(el) || lastLeft;
          const deltaX = firstLeft - lastLeft;

          // 應用位移抵消當前位置 (Invert)
          el.style.transform = `translateX(${deltaX}px)`;
          el.style.transition = 'none';
        });

        // 4) 於下一禎啟動 transition，播放到新位置
        requestAnimationFrame(() => {
          shuffled.forEach(el => {
            el.style.transition = 'transform 800ms ease';
            el.style.transform = 'translateX(0)';

            // 清理行內樣式
            el.addEventListener(
              'transitionend',
              () => {
                el.style.transition = '';
                el.style.transform = '';
              },
              { once: true }
            );
          });
        });
      };

      // 初始啟動
      setInterval(doShuffle, SHUFFLE_INTERVAL);
    }

    loadAds(frontList, containerFront, true);
    loadAds(backList, containerBack, false);

    if (containerFront) {
      containerFront.style.width = (300 * frontList.length) + "px";
    }
    
    if (containerBack) {
      containerBack.style.width = (300 * backList.length) + "px";
    }

    if (containerFront) {
      animateContainer(containerFront);
    }
    
    if (containerBack) {
      animateContainer(containerBack);
    }
  });
</script> 