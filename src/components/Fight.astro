---
// 從 API 獲取角色列表
import '../styles/fight.css';
const characterNames = ['default']; // 初始化為默認值，實際角色列表將從 API 獲取
---
<div class="fightbutton">
  <button id="fightButton">Fight</button>
</div>
<div class="fightercontainer">
  <div class="half left-container">
    <div class="image-container">
      <img
        id="leftImage"
        class="imagefighter"
        src={import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/default.png"}
        alt="Left Image"
      />
      <img
        id="leftOverlay1"
        class="overlay-image"
        src={import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/RavishingWavo.png"}
        alt="Left Overlay 1"
      />
      <img
        id="leftOverlay2"
        class="overlay-image"
        src={import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/RavishingYui.png"}
        alt="Left Overlay 2"
      />
      <img
        id="leftOverlay3"
        class="overlay-image"
        src={import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/RavishingMiku.png"}
        alt="Left Overlay 3"
      />
    </div>
    <div id="leftInfo" class="info-container">
      <div class="info" id="leftName"></div>
      <div id="leftResult" class="result-image"></div>
      <div class="info-row">
        <div class="info" id="leftPhysicPower"></div>
        <div class="info" id="leftMagicPower"></div>
        <div class="info" id="leftUtilityPower"></div>
      </div>
      <div class="info" id="leftAttributes"></div>
      <div class="info" id="leftTotalPower"></div>
    </div>
    <div class="button-container" id="leftButtons"></div>
  </div>
  <div class="half right-container">
    <div class="image-container">
      <img
        id="rightImage"
        class="imagefighter"
        src={import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/default.png"}
        alt="Right Image"
      />
      <img
        id="rightOverlay1"
        class="overlay-image"
        src={import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/RavishingWavo.png"}
        alt="Right Overlay 1"
      />
      <img
        id="rightOverlay2"
        class="overlay-image"
        src={import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/RavishingYui.png"}
        alt="Right Overlay 2"
      />
      <img
        id="rightOverlay3"
        class="overlay-image"
        src={import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/RavishingMiku.png"}
        alt="Right Overlay 3"
      />
    </div>
    <div id="rightInfo" class="info-container">
      <div class="info" id="rightName"></div>
      <div id="rightResult" class="result-image"></div>
      <div class="info-row">
        <div class="info" id="rightPhysicPower"></div>
        <div class="info" id="rightMagicPower"></div>
        <div class="info" id="rightUtilityPower"></div>
      </div>
      <div class="info" id="rightAttributes"></div>
      <div class="info" id="rightTotalPower"></div>
    </div>
    <div class="button-container" id="rightButtons"></div>
  </div>
</div>

<script>
import { applyWeaponDamage, calculateWeaponDamage } from "../scripts/weapon";

  // 定義類型
  interface Fighter {
    image: string | null;
    totalPower: number;
    name: string | null;
    nameOriginal?: string;
    physicPower?: number;
    magicPower?: number;
    utilityPower?: number;
    attributes?: string;
  }

  interface SideFighters {
    main: Fighter;
    left?: Fighter;
    right?: Fighter;
  }

  interface Fighters {
    left: SideFighters;
    right: SideFighters;
  }

  // 全局設置與狀態
  const config = {
    baseImagePath: import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/",
    apiEndpoint: `${import.meta.env.PUBLIC_TYMB_URL}/people/get-by-name`,
    defaultImage: import.meta.env.PUBLIC_PEOPLE_IMAGE_URL + "/default.png",
    sideOffset: 75 // 側邊角色的偏移量
  };
  
  // 初始化角色列表
  let characterNames = ['default'];
  
  // 添加戰鬥狀態追蹤
  let fightCompleted = false;
  
  // 從 API 獲取角色列表
  async function fetchCharacterList() {
    try {
      const response = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/people/get-all`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error('Failed to fetch character list');
      }
      
      const data = await response.json();
      
      // 檢查每個角色是否有對應的圖片
      const validCharacters = await Promise.all(
        data.map(async char => {
          const imagePath = `${config.baseImagePath}${char.name}.png`;
          try {
            const imgResponse = await fetch(imagePath);
            if (imgResponse.ok) {
              return char.name;
            }
            return null;
          } catch {
            return null;
          }
        })
      );
      
      // 過濾掉沒有圖片的角色
      characterNames = validCharacters.filter(name => name !== null);
      
      // 更新按鈕
      createButtons("leftButtons", "left");
      createButtons("rightButtons", "right");
    } catch (error) {
      console.error('Error fetching character list:', error);
      characterNames = ['default']; // 如果出錯，只保留默認角色
    }
  }
  
  // 紀錄選擇的角色
  const fighters: Fighters = {
    left: {
      main: { image: null, totalPower: 0, name: null },
      left: undefined,
      right: undefined
    },
    right: {
      main: { image: null, totalPower: 0, name: null },
      left: undefined,
      right: undefined
    }
  };
  
  // DOM 元素快速訪問
  const elements = {
    leftImage: document.getElementById("leftImage") as HTMLImageElement,
    rightImage: document.getElementById("rightImage") as HTMLImageElement,
    leftButtons: document.getElementById("leftButtons"),
    rightButtons: document.getElementById("rightButtons")
  };
  
  // 初始化函數
  function init() {
    fetchCharacterList();  // 獲取角色列表
    createSideContainers('left');
    createSideContainers('right');
  }
  
  // 創建角色選擇按鈕
  function createButtons(containerId: string, side: 'left' | 'right') {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = "";
    
    characterNames.forEach(name => {
      const button = document.createElement("button");
      button.textContent = name;
      button.className = "button";
      button.onclick = () => selectFighter(side, `${config.baseImagePath}${name}.png`);
      container.appendChild(button);
    });
  }
  
  // 創建側邊角色容器
  function createSideContainers(side: 'left' | 'right') {
    const mainContainer = document.querySelector(`.${side}-container`);
    if (!mainContainer) return;

    // 創建左側容器
    const leftContainer = document.createElement('div');
    leftContainer.className = `${side}-side-container left-side`;
    leftContainer.style.position = 'absolute';
    leftContainer.style.left = `-${config.sideOffset}px`;
    leftContainer.style.top = '0';
    leftContainer.style.width = '400px';
    leftContainer.style.height = '400px';
    leftContainer.style.zIndex = '40';

    // 創建右側容器
    const rightContainer = document.createElement('div');
    rightContainer.className = `${side}-side-container right-side`;
    rightContainer.style.position = 'absolute';
    rightContainer.style.right = `-${config.sideOffset}px`;
    rightContainer.style.top = '0';
    rightContainer.style.width = '400px';
    rightContainer.style.height = '400px';
    rightContainer.style.zIndex = '40';

    // 創建圖片元素
    const leftImage = document.createElement('img');
    leftImage.className = 'imagefighter side-image';
    leftImage.style.width = '100%';
    leftImage.style.height = '100%';
    leftImage.style.objectFit = 'contain';
    leftImage.style.display = 'none';

    const rightImage = document.createElement('img');
    rightImage.className = 'imagefighter side-image';
    rightImage.style.width = '100%';
    rightImage.style.height = '100%';
    rightImage.style.objectFit = 'contain';
    rightImage.style.display = 'none';

    leftContainer.appendChild(leftImage);
    rightContainer.appendChild(rightImage);

    mainContainer.appendChild(leftContainer);
    mainContainer.appendChild(rightContainer);
  }
  
  // 清除所有效果
  function clearAllEffects() {
    const sides = ['left', 'right'];
    sides.forEach(side => {
      // 清除角色圖片效果
      const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      const leftImage = document.querySelector(`.${side}-side-container.left-side .side-image`) as HTMLImageElement;
      const rightImage = document.querySelector(`.${side}-side-container.right-side .side-image`) as HTMLImageElement;

      [mainImage, leftImage, rightImage].forEach(image => {
        if (image) {
          image.classList.remove('shake', 'shake-hard', 'shake-extreme', 'glow', 'glow-strong', 'glow-extreme');
        }
      });

      // 清除疊加圖片效果
      const overlays = [
        document.getElementById(`${side}Overlay1`),
        document.getElementById(`${side}Overlay2`),
        document.getElementById(`${side}Overlay3`)
      ];
      
      overlays.forEach(overlay => {
        if (overlay) {
          overlay.classList.remove('active', 'slide-in-right', 'slide-in-left', 'scale-in');
          overlay.style.transform = '';
          overlay.style.opacity = '0';
        }
      });
    });
  }
  
  // 選擇角色
  function selectFighter(side: 'left' | 'right', imagePath: string) {
    const otherSide = side === "left" ? "right" : "left";
    const selectedName = characterNames.find(name => name === imagePath.split("/").pop()?.split(".")[0]) || null;
    
    // 如果戰鬥已經完成，選擇新角色時清除所有角色
    if (fightCompleted) {
      resetSideSelection('left');
      resetSideSelection('right');
      fightCompleted = false;
      
      // 啟用 Fight 按鈕
      const fightButton = document.getElementById('fightButton') as HTMLButtonElement;
      if (fightButton) {
        fightButton.disabled = false;
        fightButton.style.opacity = '1';
        fightButton.style.cursor = 'pointer';
      }
      
      // 清除所有按鈕的禁用狀態
      document.querySelectorAll("#leftButtons .button, #rightButtons .button").forEach(button => {
        button.classList.remove("disabled");
      });
      
      // 直接選擇新角色，不檢查是否已被選擇
      clearAllEffects();
      
      fighters[side].main.image = imagePath;
      fighters[side].main.name = selectedName;
      const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      if (mainImage) mainImage.src = imagePath;
      
      updateButtonStates();
      fetchFighterInfo(side, imagePath);
      return;
    }
    
    // 如果戰鬥未完成，則檢查角色是否已被選擇
    if (isCharacterSelected(otherSide, selectedName)) {
      return;
    }

    // 如果是選擇第一個角色，清空所有 localStorage 數據
    if (!fighters.left.main.image && !fighters.right.main.image) {
      localStorage.clear();
      console.log('Cleared all localStorage data before selecting first character');
    }

    clearAllEffects();
    
    if (!fighters[side].main.image) {
      fighters[side].main.image = imagePath;
      fighters[side].main.name = selectedName;
      const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      if (mainImage) mainImage.src = imagePath;
    } else if (!fighters[side].left?.image) {
      fighters[side].left = { image: imagePath, totalPower: 0, name: selectedName };
      const leftImage = document.querySelector(`.${side}-side-container.left-side .side-image`) as HTMLImageElement;
      if (leftImage) {
        leftImage.src = imagePath;
        leftImage.style.display = 'block';
      }
    } else if (!fighters[side].right?.image) {
      fighters[side].right = { image: imagePath, totalPower: 0, name: selectedName };
      const rightImage = document.querySelector(`.${side}-side-container.right-side .side-image`) as HTMLImageElement;
      if (rightImage) {
        rightImage.src = imagePath;
        rightImage.style.display = 'block';
      }
    } else {
      resetSideSelection(side);
      fighters[side].main.image = imagePath;
      fighters[side].main.name = selectedName;
      const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      if (mainImage) mainImage.src = imagePath;
    }

    updateButtonStates();
    fetchFighterInfo(side, imagePath);
  }
  
  // 檢查角色是否已被選擇
  function isCharacterSelected(side: 'left' | 'right', name: string | null): boolean {
    if (!name) return false;
    // 檢查所有已選擇的角色（包括兩邊）
    return fighters.left.main.name === name || 
           fighters.left.left?.name === name || 
           fighters.left.right?.name === name ||
           fighters.right.main.name === name || 
           fighters.right.left?.name === name || 
           fighters.right.right?.name === name;
  }

  // 重置一側的所有選擇
  function resetSideSelection(side: 'left' | 'right') {
    fighters[side].main = { image: null, totalPower: 0, name: null, physicPower: 0, magicPower: 0, utilityPower: 0, attributes: "" };
    fighters[side].left = undefined;
    fighters[side].right = undefined;

    const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
    const leftImage = document.querySelector(`.${side}-side-container.left-side .side-image`) as HTMLImageElement;
    const rightImage = document.querySelector(`.${side}-side-container.right-side .side-image`) as HTMLImageElement;

    if (mainImage) mainImage.src = config.defaultImage;
    if (leftImage) {
      leftImage.src = '';
      leftImage.style.display = 'none';
    }
    if (rightImage) {
      rightImage.src = '';
      rightImage.style.display = 'none';
    }

    // 清除 localStorage 數據
    clearLocalStorage(side);
  }
  
  // 更新按鈕狀態
  function updateButtonStates() {
    const selectedNames = new Set([
      fighters.left.main.name,
      fighters.left.left?.name,
      fighters.left.right?.name,
      fighters.right.main.name,
      fighters.right.left?.name,
      fighters.right.right?.name
    ].filter(Boolean));
    
    document.querySelectorAll("#leftButtons .button, #rightButtons .button").forEach(button => {
      button.classList.toggle("disabled", selectedNames.has(button.textContent));
    });
  }
  
  // 獲取角色資訊
  async function fetchFighterInfo(side: 'left' | 'right', imagePath: string) {
    try {
      const name = characterNames.find(n => n === imagePath.split("/").pop()?.split(".")[0]);
      const apiName = name;
      
      // 獲取角色資訊
      const response = await fetch(config.apiEndpoint, {
        method: "POST",
        headers: { 
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        body: JSON.stringify({ name: apiName }),
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error(`API 返回錯誤: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data && data.name) {
        // 獲取武器資訊 (改用新 API)
        const ownerName = name || '';
        const weaponResponse = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/weapons/owner/${ownerName}`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          credentials: 'include'
        });

        if (weaponResponse.ok) {
          const weaponData = await weaponResponse.json();
          
          // 使用新的武器傷害計算邏輯
          const { character: updatedCharacter, hasBonus } = await applyWeaponDamage(data, weaponData);
          
          // 更新數據中的 utilityPower
          data.utilityPower = updatedCharacter.utilityPower;
          
          // 不再在這裡顯示狀態效果，而是在戰鬥開始時顯示
          // 將武器數據保存到角色數據中，以便戰鬥時使用
          data.weaponData = weaponData;
          data.hasBonus = hasBonus;
        }

        updateFighterInfo(side, data);
        // 儲存到 localStorage
        saveToLocalStorage(side, data);
        return;
      }
      throw new Error("API 沒有返回有效數據");
    } catch (error) {
      console.error("獲取角色資訊失敗:", error);
      clearFighterInfo(side);
    }
  }
  
  // 更新角色資訊
  function updateFighterInfo(side: 'left' | 'right', fighter: any) {
    // 從 localStorage 獲取累加的值
    const storageKey = `fighters_${side}`;
    const storedData = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // 獲取當前顯示的角色列表
    const displayedCharacters: string[] = [];
    if (fighters[side].main.image) {
      const mainName = fighters[side].main.image.split("/").pop()?.split(".")[0];
      if (mainName) displayedCharacters.push(mainName);
    }
    if (fighters[side].left?.image) {
      const leftName = fighters[side].left.image.split("/").pop()?.split(".")[0];
      if (leftName) displayedCharacters.push(leftName);
    }
    if (fighters[side].right?.image) {
      const rightName = fighters[side].right.image.split("/").pop()?.split(".")[0];
      if (rightName) displayedCharacters.push(rightName);
    }

    // 使用 localStorage 中的值，如果沒有則使用當前角色的值
    const physicPower = storedData.physicPower || parseInt(String(fighter.physicPower || 0), 10);
    const magicPower = storedData.magicPower || parseInt(String(fighter.magicPower || 0), 10);
    const utilityPower = storedData.utilityPower || parseInt(String(fighter.utilityPower || 0), 10);
    const totalPower = physicPower + magicPower + utilityPower;
    
    // 顯示角色名稱，使用 localStorage 中的名稱列表
    const nameElement = document.getElementById(`${side}Name`);
    if (nameElement) {
      const names = storedData.nameOriginal || [];
      nameElement.textContent = names.join('、') || (fighter.nameOriginal || fighter.name) || "N/A";
    }
    
    const physicPowerElement = document.getElementById(`${side}PhysicPower`);
    const magicPowerElement = document.getElementById(`${side}MagicPower`);
    const utilityPowerElement = document.getElementById(`${side}UtilityPower`);
    
    if (physicPowerElement) physicPowerElement.textContent = `Physic Power: ${physicPower}`;
    if (magicPowerElement) magicPowerElement.textContent = `Magic Power: ${magicPower}`;
    if (utilityPowerElement) utilityPowerElement.textContent = `Utility Power: ${utilityPower}`;
    
    // 顯示屬性，使用 localStorage 中的屬性列表
    const attributesElement = document.getElementById(`${side}Attributes`);
    if (attributesElement) {
      const attributes = storedData.attributes || [];
      attributesElement.textContent = `Attributes: ${attributes.join('、') || (fighter.attributes || "N/A")}`;
    }
    
    // 顯示總力量
    const totalPowerElement = document.getElementById(`${side}TotalPower`);
    if (totalPowerElement) totalPowerElement.textContent = `Total Power: ${totalPower}`;
    
    // 確保存儲的總力量是數字
    fighters[side].main.totalPower = totalPower;
    fighters[side].main.nameOriginal = fighter.nameOriginal;
  }
  
  // 清除角色資訊
  function clearFighterInfo(side: 'left' | 'right') {
    const elements = [
      `${side}Name`,
      `${side}PhysicPower`,
      `${side}MagicPower`,
      `${side}UtilityPower`,
      `${side}Attributes`,
      `${side}TotalPower`
    ];
    
    elements.forEach(id => {
      const element = document.getElementById(id);
      if (element) element.textContent = "";
    });
    
    fighters[side].main.totalPower = 0;
    fighters[side].main.nameOriginal = undefined;
  }
  
  // 檢查並載入戰鬥版本的圖片
  async function loadFightingImage(side: 'left' | 'right', originalImagePath: string): Promise<string> {
    try {
      // 檢查當前圖片是否已經是 ruined 圖片
      const currentImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      if (currentImage && currentImage.src.includes('Ruined.png')) {
        return currentImage.src; // 如果已經是 ruined 圖片，直接返回當前圖片路徑
      }

      const originalName = originalImagePath.split("/").pop()?.split(".")[0];
      if (!originalName) return originalImagePath;

      const fightingImagePath = `${import.meta.env.PUBLIC_PEOPLE_IMAGE_URL}/${originalName}Fighting.png`;
      const response = await fetch(fightingImagePath);
      
      if (response.ok) {
        return fightingImagePath;
      }
    } catch (error) {
      console.error(`Error loading fighting image for ${side}:`, error);
    }
    return originalImagePath;
  }
  
  // 檢查並載入戰敗版本的圖片
  async function loadRuinedImage(side: 'left' | 'right', currentImagePath: string): Promise<string> {
    try {
      // 檢查當前圖片是否已經是 ruined 圖片
      const currentImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      if (currentImage && currentImage.src.includes('Ruined.png')) {
        return currentImage.src; // 如果已經是 ruined 圖片，直接返回當前圖片路徑
      }

      // 從當前圖片路徑中提取角色名稱
      const imageName = currentImagePath.split("/").pop()?.split(".")[0] || "";
      const baseName = imageName.replace("Fighting", "");
      
      if (!baseName) return currentImagePath;

      const ruinedImagePath = `${import.meta.env.PUBLIC_PEOPLE_IMAGE_URL}/${baseName}Ruined.png`;
      const response = await fetch(ruinedImagePath);
      
      if (response.ok) {
        return ruinedImagePath;
      }
    } catch (error) {
      console.error(`Error loading ruined image for ${side}:`, error);
    }
    return currentImagePath;
  }
  
  // 為夥伴載入戰敗版本的圖片
  async function loadPartnerRuinedImage(side: 'left' | 'right', currentImagePath: string): Promise<string> {
    try {
      // 從當前圖片路徑中提取角色名稱
      const imageName = currentImagePath.split("/").pop()?.split(".")[0] || "";
      const baseName = imageName.replace("Fighting", "");
      
      if (!baseName) return currentImagePath;

      const ruinedImagePath = `${import.meta.env.PUBLIC_PEOPLE_IMAGE_URL}/${baseName}Ruined.png`;
      const response = await fetch(ruinedImagePath);
      
      if (response.ok) {
        return ruinedImagePath;
      }
    } catch (error) {
      console.error(`Error loading partner ruined image for ${side}:`, error);
    }
    return currentImagePath;
  }
  
  // 添加狀態效果
  function addStateEffect(side: 'left' | 'right', states: string[]) {
    const targetImage = document.getElementById(`${side}Image`) as HTMLImageElement;
    if (!targetImage) return;

    // 依次顯示每個狀態效果
    states.forEach((state, index) => {
      setTimeout(() => {
        const stateOverlay = document.createElement('div');
        stateOverlay.className = 'state-overlay';
        stateOverlay.textContent = state;
        targetImage.parentElement?.appendChild(stateOverlay);
        
        // 1秒後移除狀態效果
        setTimeout(() => {
          stateOverlay.remove();
        }, 1000);
      }, index * 1000); // 每個狀態效果間隔1秒
    });
  }
  
  // 開始戰鬥
  async function startFight() {
    const leftPower = parseInt(String(fighters.left.main.totalPower || 0), 10);
    const rightPower = parseInt(String(fighters.right.main.totalPower || 0), 10);
    
    const leftResult = document.getElementById("leftResult");
    const rightResult = document.getElementById("rightResult");
    const leftTotalPower = document.getElementById("leftTotalPower");
    const rightTotalPower = document.getElementById("rightTotalPower");
    
    // 重設樣式和文本
    if (leftResult) leftResult.textContent = "";
    if (rightResult) rightResult.textContent = "";
    if (leftTotalPower) leftTotalPower.classList.remove("win", "defeated");
    if (rightTotalPower) rightTotalPower.classList.remove("win", "defeated");
    
    // 如果任一方未選擇角色或力量為0，顯示提示
    if (!fighters.left.main.image || !fighters.right.main.image) {
      alert("請先選擇兩邊的角色");
      return;
    }

    // 檢查角色是否已經處於 ruined 狀態
    const leftImage = document.getElementById("leftImage") as HTMLImageElement;
    const rightImage = document.getElementById("rightImage") as HTMLImageElement;
    
    const leftIsRuined = leftImage && leftImage.src.includes('Ruined.png');
    const rightIsRuined = rightImage && rightImage.src.includes('Ruined.png');
    
    // 如果雙方都已經處於 ruined 狀態，顯示提示
    if (leftIsRuined && rightIsRuined) {
      alert("雙方角色都已經戰敗，無法再次戰鬥");
      return;
    }

    // 載入戰鬥版本的圖片
    await loadFightingImages('left');
    await loadFightingImages('right');

    // 檢查並應用狀態效果
    try {
      // 從 localStorage 獲取角色數據
      const leftStorageKey = 'fighters_left';
      const rightStorageKey = 'fighters_right';
      const leftData = JSON.parse(localStorage.getItem(leftStorageKey) || '{}');
      const rightData = JSON.parse(localStorage.getItem(rightStorageKey) || '{}');
      
      // 收集左方所有角色的狀態效果
      const leftSideStates: string[] = [];
      
      // 檢查左方主角色的武器效果
      if (leftData.weaponData && leftData.hasBonus && leftData.weaponData.stateAttributes) {
        leftSideStates.push(...leftData.weaponData.stateAttributes);
      }
      
      // 檢查左方左側夥伴的武器效果
      if (fighters.left.left?.name) {
        const leftPartnerName = fighters.left.left.name;
        const leftPartnerWeaponResponse = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/weapons/owner/${leftPartnerName}`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          credentials: 'include'
        });
        
        if (leftPartnerWeaponResponse.ok) {
          const leftPartnerWeaponData = await leftPartnerWeaponResponse.json();
          const { hasBonus } = calculateWeaponDamage(fighters.left.left, leftPartnerWeaponData);
          
          if (hasBonus && leftPartnerWeaponData.stateAttributes && Array.isArray(leftPartnerWeaponData.stateAttributes)) {
            leftSideStates.push(...leftPartnerWeaponData.stateAttributes);
          }
        }
      }
      
      // 檢查左方右側夥伴的武器效果
      if (fighters.left.right?.name) {
        const leftRightPartnerName = fighters.left.right.name;
        const leftRightPartnerWeaponResponse = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/weapons/owner/${leftRightPartnerName}`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          credentials: 'include'
        });
        
        if (leftRightPartnerWeaponResponse.ok) {
          const leftRightPartnerWeaponData = await leftRightPartnerWeaponResponse.json();
          const { hasBonus } = calculateWeaponDamage(fighters.left.right, leftRightPartnerWeaponData);
          
          if (hasBonus && leftRightPartnerWeaponData.stateAttributes && Array.isArray(leftRightPartnerWeaponData.stateAttributes)) {
            leftSideStates.push(...leftRightPartnerWeaponData.stateAttributes);
          }
        }
      }
      
      // 收集右方所有角色的狀態效果
      const rightSideStates: string[] = [];
      
      // 檢查右方主角色的武器效果
      if (rightData.weaponData && rightData.hasBonus && rightData.weaponData.stateAttributes) {
        rightSideStates.push(...rightData.weaponData.stateAttributes);
      }
      
      // 檢查右方左側夥伴的武器效果
      if (fighters.right.left?.name) {
        const rightPartnerName = fighters.right.left.name;
        const rightPartnerWeaponResponse = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/weapons/owner/${rightPartnerName}`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          credentials: 'include'
        });
        
        if (rightPartnerWeaponResponse.ok) {
          const rightPartnerWeaponData = await rightPartnerWeaponResponse.json();
          const { hasBonus } = calculateWeaponDamage(fighters.right.left, rightPartnerWeaponData);
          
          if (hasBonus && rightPartnerWeaponData.stateAttributes && Array.isArray(rightPartnerWeaponData.stateAttributes)) {
            rightSideStates.push(...rightPartnerWeaponData.stateAttributes);
          }
        }
      }
      
      // 檢查右方右側夥伴的武器效果
      if (fighters.right.right?.name) {
        const rightRightPartnerName = fighters.right.right.name;
        const rightRightPartnerWeaponResponse = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/weapons/owner/${rightRightPartnerName}`, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          credentials: 'include'
        });
        
        if (rightRightPartnerWeaponResponse.ok) {
          const rightRightPartnerWeaponData = await rightRightPartnerWeaponResponse.json();
          const { hasBonus } = calculateWeaponDamage(fighters.right.right, rightRightPartnerWeaponData);
          
          if (hasBonus && rightRightPartnerWeaponData.stateAttributes && Array.isArray(rightRightPartnerWeaponData.stateAttributes)) {
            rightSideStates.push(...rightRightPartnerWeaponData.stateAttributes);
          }
        }
      }
      
      // 一次性顯示所有狀態效果
      if (leftSideStates.length > 0) {
        addStateEffect('right', leftSideStates);
      }
      
      if (rightSideStates.length > 0) {
        addStateEffect('left', rightSideStates);
      }
      
    } catch (error) {
      console.error("檢查武器狀態效果失敗:", error);
    }
    
    // 計算差距百分比
    const percentageDifference = Math.abs(leftPower - rightPower) / Math.max(leftPower, rightPower, 1);
    
    // 確定勝負
    if (leftPower > rightPower) {
      determineWinner("left", "right", leftPower, rightPower, percentageDifference);
    } else if (rightPower > leftPower) {
      determineWinner("right", "left", rightPower, leftPower, percentageDifference);
    } else {
      // 平局
      if (leftResult) leftResult.textContent = "Draw";
      if (rightResult) rightResult.textContent = "Draw";
      // 使用 nameOriginal 顯示角色名稱
      const leftName = document.getElementById("leftName");
      const rightName = document.getElementById("rightName");
      if (leftName) leftName.innerHTML = 
        `${fighters.left.main.nameOriginal || fighters.left.main.name}<br><span class='result'>draw</span>`;
      if (rightName) rightName.innerHTML = 
        `${fighters.right.main.nameOriginal || fighters.right.main.name}<br><span class='result'>draw</span>`;
    }
  }
  
  // 載入戰鬥版本的圖片
  async function loadFightingImages(side: 'left' | 'right') {
    const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
    const leftImage = document.querySelector(`.${side}-side-container.left-side .side-image`) as HTMLImageElement;
    const rightImage = document.querySelector(`.${side}-side-container.right-side .side-image`) as HTMLImageElement;

    if (mainImage && fighters[side].main.image) {
      const mainFightingImage = await loadFightingImage(side, fighters[side].main.image);
      mainImage.src = mainFightingImage;
    }

    if (leftImage && fighters[side].left?.image) {
      const leftFightingImage = await loadFightingImage(side, fighters[side].left.image);
      leftImage.src = leftFightingImage;
    }

    if (rightImage && fighters[side].right?.image) {
      const rightFightingImage = await loadFightingImage(side, fighters[side].right.image);
      rightImage.src = rightFightingImage;
    }
  }
  
  // 確定勝負和結果顯示
  function determineWinner(winnerSide: 'left' | 'right', loserSide: 'left' | 'right', winnerPower: number, loserPower: number, difference: number) {
    const winnerElement = document.getElementById(`${winnerSide}TotalPower`);
    const loserElement = document.getElementById(`${loserSide}TotalPower`);
    const winnerResult = document.getElementById(`${winnerSide}Result`);
    const loserResult = document.getElementById(`${loserSide}Result`);
    const winnerName = document.getElementById(`${winnerSide}Name`);
    const loserName = document.getElementById(`${loserSide}Name`);
    const loserImage = document.getElementById(`${loserSide}Image`) as HTMLImageElement;
    const winnerImage = document.getElementById(`${winnerSide}Image`) as HTMLImageElement;
    
    // 獲取勝利方和失敗方的夥伴圖片
    const winnerLeftImage = document.querySelector(`.${winnerSide}-side-container.left-side .side-image`) as HTMLImageElement;
    const winnerRightImage = document.querySelector(`.${winnerSide}-side-container.right-side .side-image`) as HTMLImageElement;
    const loserLeftImage = document.querySelector(`.${loserSide}-side-container.left-side .side-image`) as HTMLImageElement;
    const loserRightImage = document.querySelector(`.${loserSide}-side-container.right-side .side-image`) as HTMLImageElement;
    
    // 檢查失敗方是否已經處於 ruined 狀態
    const loserIsRuined = loserImage && loserImage.src.includes('Ruined.png');
    const loserLeftIsRuined = loserLeftImage && loserLeftImage.style.display !== 'none' && loserLeftImage.src.includes('Ruined.png');
    const loserRightIsRuined = loserRightImage && loserRightImage.style.display !== 'none' && loserRightImage.src.includes('Ruined.png');
    
    // 重設樣式
    if (winnerElement) {
      winnerElement.classList.remove("defeated");
      winnerElement.classList.add("win");
      // 根據差距設置強度
      if (difference > 0.4) {
        winnerElement.setAttribute("data-intensity", "high");
      } else if (difference > 0.1) {
        winnerElement.setAttribute("data-intensity", "medium");
      } else {
        winnerElement.setAttribute("data-intensity", "low");
      }
    }
    if (loserElement) {
      loserElement.classList.remove("win");
      loserElement.classList.add("defeated");
      // 根據差距設置強度
      if (difference > 0.4) {
        loserElement.setAttribute("data-intensity", "high");
      } else if (difference > 0.1) {
        loserElement.setAttribute("data-intensity", "medium");
      } else {
        loserElement.setAttribute("data-intensity", "low");
      }
    }
    
    // 計算失敗百分比
    const lossPercentage = ((winnerPower - loserPower) / winnerPower * 100).toFixed(2);
    
    // 顯示基本結果
    if (winnerResult) winnerResult.textContent = "Winner";
    if (loserResult) loserResult.textContent = `${lossPercentage}% Defeated`;
    
    // 根據差距程度顯示不同結果和效果
    const winnerCharName = fighters[winnerSide].main.nameOriginal || fighters[winnerSide].main.name;
    const loserCharName = fighters[loserSide].main.nameOriginal || fighters[loserSide].main.name;
    
    // 添加疊加圖像
    const loserOverlay1 = document.getElementById(`${loserSide}Overlay1`) as HTMLImageElement;
    const loserOverlay2 = document.getElementById(`${loserSide}Overlay2`) as HTMLImageElement;
    const loserOverlay3 = document.getElementById(`${loserSide}Overlay3`) as HTMLImageElement;
    if (loserOverlay1 && loserOverlay2 && loserOverlay3) {
      // 先添加左側滑入的圖像
      loserOverlay2.classList.add('active', 'slide-in-left');
      
      // 延遲添加右側滑入的圖像
      setTimeout(() => {
        loserOverlay1.classList.add('active', 'slide-in-right');
      }, 250);

      // 延遲添加第三張圖像（從後方縮放出現）
      setTimeout(() => {
        loserOverlay3.classList.add('active', 'scale-in');
      }, 500);
    }
    
    // 清除之前的動畫類
    if (winnerImage) {
      winnerImage.classList.remove('glow', 'glow-strong', 'glow-extreme', 'victory-effect');
      // 強制重新應用動畫
      void winnerImage.offsetWidth; // 觸發重排
      winnerImage.classList.add('victory-jump');
    }
    
    if (winnerLeftImage && winnerLeftImage.style.display !== 'none') {
      winnerLeftImage.classList.remove('victory-jump');
      void winnerLeftImage.offsetWidth; // 觸發重排
      winnerLeftImage.classList.add('victory-jump');
    }
    
    if (winnerRightImage && winnerRightImage.style.display !== 'none') {
      winnerRightImage.classList.remove('victory-jump');
      void winnerRightImage.offsetWidth; // 觸發重排
      winnerRightImage.classList.add('victory-jump');
    }

    // 為失敗的角色和其夥伴添加晃動效果
    if (loserImage) {
      loserImage.classList.remove('shake', 'shake-hard', 'shake-extreme');
      void loserImage.offsetWidth; // 觸發重排
      loserImage.classList.add('defeat-shake');
    }

    if (loserLeftImage && loserLeftImage.style.display !== 'none') {
      loserLeftImage.classList.remove('defeat-shake');
      void loserLeftImage.offsetWidth; // 觸發重排
      loserLeftImage.classList.add('defeat-shake');
    }

    if (loserRightImage && loserRightImage.style.display !== 'none') {
      loserRightImage.classList.remove('defeat-shake');
      void loserRightImage.offsetWidth; // 觸發重排
      loserRightImage.classList.add('defeat-shake');
    }
    
    if (difference > 0.4) {
      if (winnerName) {
        winnerName.innerHTML = `${winnerCharName}<br><span class='result' style='color: #00ff00; text-shadow: 0 0 8px rgba(0, 255, 0, 0.5); font-size: 18px; font-weight: bold;'>Destroying</span>`;
      }
      if (loserName) {
        loserName.innerHTML = `${loserCharName}<br><span class='result' style='color: #ff0000; text-shadow: 0 0 8px rgba(255, 0, 0, 0.5); font-size: 18px; font-weight: bold;'>Fucked Up</span>`;
      }
    } else if (difference > 0.1) {
      if (winnerName) {
        winnerName.innerHTML = `${winnerCharName}<br><span class='result' style='color: #00cc00; text-shadow: 0 0 6px rgba(0, 204, 0, 0.4); font-size: 18px; font-weight: bold;'>Destroying</span>`;
      }
      if (loserName) {
        loserName.innerHTML = `${loserCharName}<br><span class='result' style='color: #cc0000; text-shadow: 0 0 6px rgba(204, 0, 0, 0.4); font-size: 18px; font-weight: bold;'>Fucked Up</span>`;
      }
    } else {
      if (winnerName) {
        winnerName.innerHTML = `${winnerCharName}<br><span class='result' style='color: #009900; text-shadow: 0 0 4px rgba(0, 153, 0, 0.3); font-size: 18px; font-weight: bold;'>Destroying</span>`;
      }
      if (loserName) {
        loserName.innerHTML = `${loserCharName}<br><span class='result' style='color: #990000; text-shadow: 0 0 4px rgba(153, 0, 0, 0.3); font-size: 18px; font-weight: bold;'>Fucked Up</span>`;
      }
    }

    // 動畫結束後移除效果
    setTimeout(() => {
      if (loserImage) loserImage.classList.remove('defeat-shake');
      if (loserLeftImage) loserLeftImage.classList.remove('defeat-shake');
      if (loserRightImage) loserRightImage.classList.remove('defeat-shake');
      if (winnerImage) winnerImage.classList.remove('victory-jump');
      if (winnerLeftImage) winnerLeftImage.classList.remove('victory-jump');
      if (winnerRightImage) winnerRightImage.classList.remove('victory-jump');
    }, 500);
    
    // 等待 2 秒後顯示戰敗/戰勝效果
    setTimeout(async () => {
      // 為輸家的主角色載入戰敗圖片，但只有在不是已經處於 ruined 狀態時才載入
      if (loserImage && !loserIsRuined) {
        const currentSrc = loserImage.src;
        const ruinedImagePath = await loadRuinedImage(loserSide, currentSrc);
        if (ruinedImagePath !== currentSrc) {
          loserImage.src = ruinedImagePath;
          loserImage.classList.add('ruined-effect');
          // 移除持續的戰敗效果
          // loserImage.style.filter = 'brightness(80%) saturate(80%)';
        }
      }
      
      // 為輸家的左側夥伴載入戰敗圖片，但只有在不是已經處於 ruined 狀態時才載入
      if (loserLeftImage && loserLeftImage.style.display !== 'none' && !loserLeftIsRuined) {
        const currentSrc = loserLeftImage.src;
        // 從當前圖片路徑中提取角色名稱
        const imageName = currentSrc.split("/").pop()?.split(".")[0] || "";
        const baseName = imageName.replace("Fighting", "");
        
        if (baseName) {
          const ruinedImagePath = `${import.meta.env.PUBLIC_PEOPLE_IMAGE_URL}/${baseName}Ruined.png`;
          try {
            const response = await fetch(ruinedImagePath);
            if (response.ok && ruinedImagePath !== currentSrc) {
              loserLeftImage.src = ruinedImagePath;
              loserLeftImage.classList.add('ruined-effect');
              // 移除持續的戰敗效果
              // loserLeftImage.style.filter = 'brightness(80%) saturate(80%)';
            }
          } catch (error) {
            console.error(`Error loading partner ruined image for ${loserSide} left:`, error);
          }
        }
      }
      
      // 為輸家的右側夥伴載入戰敗圖片，但只有在不是已經處於 ruined 狀態時才載入
      if (loserRightImage && loserRightImage.style.display !== 'none' && !loserRightIsRuined) {
        const currentSrc = loserRightImage.src;
        // 從當前圖片路徑中提取角色名稱
        const imageName = currentSrc.split("/").pop()?.split(".")[0] || "";
        const baseName = imageName.replace("Fighting", "");
        
        if (baseName) {
          const ruinedImagePath = `${import.meta.env.PUBLIC_PEOPLE_IMAGE_URL}/${baseName}Ruined.png`;
          try {
            const response = await fetch(ruinedImagePath);
            if (response.ok && ruinedImagePath !== currentSrc) {
              loserRightImage.src = ruinedImagePath;
              loserRightImage.classList.add('ruined-effect');
              // 移除持續的戰敗效果
              // loserRightImage.style.filter = 'brightness(80%) saturate(80%)';
            }
          } catch (error) {
            console.error(`Error loading partner ruined image for ${loserSide} right:`, error);
          }
        }
      }
      
      // 戰鬥完成後禁用 Fight 按鈕
      fightCompleted = true;
      const fightButton = document.getElementById('fightButton') as HTMLButtonElement;
      if (fightButton) {
        fightButton.disabled = true;
        fightButton.style.opacity = '0.5';
        fightButton.style.cursor = 'not-allowed';
      }
    }, 2000);
  }
  
  // 頁面載入時初始化
  window.onload = () => {
    init();
    // 添加 Fight 按鈕的點擊事件監聽器
    const fightButton = document.getElementById('fightButton');
    if (fightButton) {
      fightButton.addEventListener('click', startFight);
    }
  };

  // 儲存到 localStorage
  function saveToLocalStorage(side: 'left' | 'right', fighter: any) {
    const storageKey = `fighters_${side}`;
    let currentData = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // 初始化數據結構
    if (!currentData.physicPower) currentData.physicPower = 0;
    if (!currentData.magicPower) currentData.magicPower = 0;
    if (!currentData.utilityPower) currentData.utilityPower = 0;
    if (!currentData.nameOriginal) currentData.nameOriginal = [];
    if (!currentData.attributes) currentData.attributes = [];

    // 獲取當前選擇的角色名稱
    const currentName = fighter.nameOriginal || fighter.name;
    if (!currentName) return;

    // 檢查當前角色是否已經在列表中
    const isAlreadyAdded = currentData.nameOriginal.includes(currentName);
    
    // 如果角色已經存在，不重複添加
    if (!isAlreadyAdded) {
      // 累加數值
      currentData.physicPower += parseInt(String(fighter.physicPower || 0), 10);
      currentData.magicPower += parseInt(String(fighter.magicPower || 0), 10);
      currentData.utilityPower += parseInt(String(fighter.utilityPower || 0), 10);

      // 添加名稱和屬性
      currentData.nameOriginal.push(currentName);
      const attributes = fighter.attributes;
      if (attributes && !currentData.attributes.includes(attributes)) {
        currentData.attributes.push(attributes);
      }
      
      // 保存武器數據和加成狀態
      if (fighter.weaponData) {
        currentData.weaponData = fighter.weaponData;
      }
      if (fighter.hasBonus !== undefined) {
        currentData.hasBonus = fighter.hasBonus;
      }

      // 儲存回 localStorage
      localStorage.setItem(storageKey, JSON.stringify(currentData));

      // 輸出到控制台以便檢查
      console.log(`${side} side localStorage data:`, currentData);
      console.log(`Added character: ${currentName}`);

      // 立即更新顯示
      updateFighterInfo(side, currentData);
    } else {
      console.log(`Character ${currentName} already exists in localStorage`);
    }
  }

  // 清除 localStorage 數據
  function clearLocalStorage(side: 'left' | 'right') {
    localStorage.removeItem(`fighters_${side}`);
    console.log(`Cleared ${side} side localStorage data`);
  }
</script>

<script define:vars={{ characterNames }}>
  // 將角色名稱列表傳遞給客戶端腳本
  document.currentScript?.setAttribute('data-characters', JSON.stringify(characterNames));
</script>



