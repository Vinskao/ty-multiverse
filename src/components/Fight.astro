---
// 從 API 獲取角色列表
import '../styles/fight.css';
const characterNames = ['default']; // 初始化為默認值，實際角色列表將從 API 獲取
---

<div class="fightbutton">
  <button id="fightButton">Fight</button>
</div>
<div class="fightercontainer">
  <div class="half left-container">
    <div class="image-container">
      <img
        id="leftImage"
        class="imagefighter"
        src="/tymultiverse/assets/person/default.png"
        alt="Left Image"
      />
      <img
        id="leftOverlay1"
        class="overlay-image"
        src="/tymultiverse/assets/person/RavishingWavo.png"
        alt="Left Overlay 1"
      />
      <img
        id="leftOverlay2"
        class="overlay-image"
        src="/tymultiverse/assets/person/RavishingYui.png"
        alt="Left Overlay 2"
      />
      <img
        id="leftOverlay3"
        class="overlay-image"
        src="/tymultiverse/assets/person/RavishingMiku.png"
        alt="Left Overlay 3"
      />
    </div>
    <div id="leftInfo" class="info-container">
      <div class="info" id="leftName"></div>
      <div id="leftResult" class="result-image"></div>
      <div class="info-row">
        <div class="info" id="leftPhysicPower"></div>
        <div class="info" id="leftMagicPower"></div>
        <div class="info" id="leftUtilityPower"></div>
      </div>
      <div class="info" id="leftAttributes"></div>
      <div class="info" id="leftTotalPower"></div>
    </div>
    <div class="button-container" id="leftButtons"></div>
  </div>
  <div class="half right-container">
    <div class="image-container">
      <img
        id="rightImage"
        class="imagefighter"
        src="/tymultiverse/assets/person/default.png"
        alt="Right Image"
      />
      <img
        id="rightOverlay1"
        class="overlay-image"
        src="/tymultiverse/assets/person/RavishingWavo.png"
        alt="Right Overlay 1"
      />
      <img
        id="rightOverlay2"
        class="overlay-image"
        src="/tymultiverse/assets/person/RavishingYui.png"
        alt="Right Overlay 2"
      />
      <img
        id="rightOverlay3"
        class="overlay-image"
        src="/tymultiverse/assets/person/RavishingMiku.png"
        alt="Right Overlay 3"
      />
    </div>
    <div id="rightInfo" class="info-container">
      <div class="info" id="rightName"></div>
      <div id="rightResult" class="result-image"></div>
      <div class="info-row">
        <div class="info" id="rightPhysicPower"></div>
        <div class="info" id="rightMagicPower"></div>
        <div class="info" id="rightUtilityPower"></div>
      </div>
      <div class="info" id="rightAttributes"></div>
      <div class="info" id="rightTotalPower"></div>
    </div>
    <div class="button-container" id="rightButtons"></div>
  </div>
</div>

<script>
  // 定義類型
  interface Fighter {
    image: string | null;
    totalPower: number;
    name: string | null;
    nameOriginal?: string;
    physicPower?: number;
    magicPower?: number;
    utilityPower?: number;
    attributes?: string;
  }

  interface SideFighters {
    main: Fighter;
    left?: Fighter;
    right?: Fighter;
  }

  interface Fighters {
    left: SideFighters;
    right: SideFighters;
  }

  // 全局設置與狀態
  const config = {
    baseImagePath: "/tymultiverse/assets/person/",
    apiEndpoint: `${import.meta.env.PUBLIC_TYMB_URL}/people/get-by-name`,
    defaultImage: "/tymultiverse/assets/person/default.png",
    sideOffset: 75 // 側邊角色的偏移量
  };
  
  // 初始化角色列表
  let characterNames = ['default'];
  
  // 刷新 token 的函數
  async function refreshToken() {
    try {
      // 從 URL 參數中獲取 refresh token
      const urlParams = new URLSearchParams(window.location.search);
      const refreshToken = urlParams.get('refresh_token');
      
      if (!refreshToken) {
        console.error('No refresh token available');
        window.location.href = '/tymultiverse/login';
        return false;
      }

      const response = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/keycloak/refresh`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        body: JSON.stringify({ refresh_token: refreshToken }),
        credentials: 'include'
      });

      if (!response.ok) {
        console.error('Token refresh failed:', response.status);
        window.location.href = '/tymultiverse/login';
        return false;
      }

      const data = await response.json();
      if (data.token) {
        // 更新 URL 中的 token
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.set('token', data.token);
        if (data.refresh_token) {
          currentUrl.searchParams.set('refresh_token', data.refresh_token);
        }
        window.history.replaceState({}, '', currentUrl.toString());
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error refreshing token:', error);
      window.location.href = '/tymultiverse/login';
      return false;
    }
  }

  // 驗證 token 是否有效
  async function verifyToken(token: string) {
    try {
      const response = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/keycloak/introspect?token=${token}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json',
        },
        credentials: 'include'
      });

      if (response.ok) {
        const data = await response.json();
        return data.active;
      }
      return false;
    } catch (error) {
      console.error('Token verification failed:', error);
      return false;
    }
  }

  // 獲取有效的 token
  async function getValidToken() {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    
    if (!token) {
      console.error('No token available');
      window.location.href = '/tymultiverse/login';
      return null;
    }

    const isValid = await verifyToken(token);
    if (isValid) {
      return token;
    }

    const refreshed = await refreshToken();
    if (!refreshed) {
      return null;
    }

    // 重新獲取更新後的 token
    const newUrlParams = new URLSearchParams(window.location.search);
    return newUrlParams.get('token');
  }
  
  // 從 API 獲取角色列表
  async function fetchCharacterList() {
    try {
      const token = await getValidToken();
      if (!token) {
        return;
      }

      const response = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/people/get-all`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
          "Accept": "application/json"
        },
        credentials: 'include'
      });
      
      if (!response.ok) {
        if (response.status === 401) {
          const newToken = await getValidToken();
          if (!newToken) {
            return;
          }
          // 重試請求
          return fetchCharacterList();
        }
        throw new Error('Failed to fetch character list');
      }
      
      const data = await response.json();
      
      // 檢查每個角色是否有對應的圖片
      const validCharacters = await Promise.all(
        data.map(async char => {
          const imagePath = `${config.baseImagePath}${char.name}.png`;
          try {
            const imgResponse = await fetch(imagePath);
            if (imgResponse.ok) {
              return char.name;
            }
            return null;
          } catch {
            return null;
          }
        })
      );
      
      // 過濾掉沒有圖片的角色
      characterNames = validCharacters.filter(name => name !== null);
      
      // 更新按鈕
      createButtons("leftButtons", "left");
      createButtons("rightButtons", "right");
    } catch (error) {
      console.error('Error fetching character list:', error);
      characterNames = ['default']; // 如果出錯，只保留默認角色
    }
  }
  
  // 紀錄選擇的角色
  const fighters: Fighters = {
    left: {
      main: { image: null, totalPower: 0, name: null },
      left: undefined,
      right: undefined
    },
    right: {
      main: { image: null, totalPower: 0, name: null },
      left: undefined,
      right: undefined
    }
  };
  
  // DOM 元素快速訪問
  const elements = {
    leftImage: document.getElementById("leftImage") as HTMLImageElement,
    rightImage: document.getElementById("rightImage") as HTMLImageElement,
    leftButtons: document.getElementById("leftButtons"),
    rightButtons: document.getElementById("rightButtons")
  };
  
  // 初始化函數
  function init() {
    fetchCharacterList();  // 獲取角色列表
    createSideContainers('left');
    createSideContainers('right');
  }
  
  // 創建角色選擇按鈕
  function createButtons(containerId: string, side: 'left' | 'right') {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = "";
    
    characterNames.forEach(name => {
      const button = document.createElement("button");
      button.textContent = name;
      button.className = "button";
      button.onclick = () => selectFighter(side, `${config.baseImagePath}${name}.png`);
      container.appendChild(button);
    });
  }
  
  // 創建側邊角色容器
  function createSideContainers(side: 'left' | 'right') {
    const mainContainer = document.querySelector(`.${side}-container`);
    if (!mainContainer) return;

    // 創建左側容器
    const leftContainer = document.createElement('div');
    leftContainer.className = `${side}-side-container left-side`;
    leftContainer.style.position = 'absolute';
    leftContainer.style.left = `-${config.sideOffset}px`;
    leftContainer.style.top = '0';
    leftContainer.style.width = '400px';
    leftContainer.style.height = '400px';
    leftContainer.style.zIndex = '40';

    // 創建右側容器
    const rightContainer = document.createElement('div');
    rightContainer.className = `${side}-side-container right-side`;
    rightContainer.style.position = 'absolute';
    rightContainer.style.right = `-${config.sideOffset}px`;
    rightContainer.style.top = '0';
    rightContainer.style.width = '400px';
    rightContainer.style.height = '400px';
    rightContainer.style.zIndex = '40';

    // 創建圖片元素
    const leftImage = document.createElement('img');
    leftImage.className = 'imagefighter side-image';
    leftImage.style.width = '100%';
    leftImage.style.height = '100%';
    leftImage.style.objectFit = 'contain';
    leftImage.style.display = 'none';

    const rightImage = document.createElement('img');
    rightImage.className = 'imagefighter side-image';
    rightImage.style.width = '100%';
    rightImage.style.height = '100%';
    rightImage.style.objectFit = 'contain';
    rightImage.style.display = 'none';

    leftContainer.appendChild(leftImage);
    rightContainer.appendChild(rightImage);

    mainContainer.appendChild(leftContainer);
    mainContainer.appendChild(rightContainer);
  }
  
  // 清除所有效果
  function clearAllEffects() {
    const sides = ['left', 'right'];
    sides.forEach(side => {
      // 清除角色圖片效果
      const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      const leftImage = document.querySelector(`.${side}-side-container.left-side .side-image`) as HTMLImageElement;
      const rightImage = document.querySelector(`.${side}-side-container.right-side .side-image`) as HTMLImageElement;

      [mainImage, leftImage, rightImage].forEach(image => {
        if (image) {
          image.classList.remove('shake', 'shake-hard', 'shake-extreme', 'glow', 'glow-strong', 'glow-extreme');
        }
      });

      // 清除疊加圖片效果
      const overlays = [
        document.getElementById(`${side}Overlay1`),
        document.getElementById(`${side}Overlay2`),
        document.getElementById(`${side}Overlay3`)
      ];
      
      overlays.forEach(overlay => {
        if (overlay) {
          overlay.classList.remove('active', 'slide-in-right', 'slide-in-left', 'scale-in');
          overlay.style.transform = '';
          overlay.style.opacity = '0';
        }
      });
    });
  }

  // 選擇角色
  function selectFighter(side: 'left' | 'right', imagePath: string) {
    const otherSide = side === "left" ? "right" : "left";
    const selectedName = characterNames.find(name => name === imagePath.split("/").pop()?.split(".")[0]);
    
    if (isCharacterSelected(otherSide, selectedName)) {
      return;
    }

    // 如果是選擇第一個角色，清空所有 localStorage 數據
    if (!fighters.left.main.image && !fighters.right.main.image) {
      localStorage.clear();
      console.log('Cleared all localStorage data before selecting first character');
    }

    clearAllEffects();
    
    if (!fighters[side].main.image) {
      fighters[side].main.image = imagePath;
      fighters[side].main.name = selectedName;
      const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      if (mainImage) mainImage.src = imagePath;
    } else if (!fighters[side].left?.image) {
      fighters[side].left = { image: imagePath, totalPower: 0, name: selectedName };
      const leftImage = document.querySelector(`.${side}-side-container.left-side .side-image`) as HTMLImageElement;
      if (leftImage) {
        leftImage.src = imagePath;
        leftImage.style.display = 'block';
      }
    } else if (!fighters[side].right?.image) {
      fighters[side].right = { image: imagePath, totalPower: 0, name: selectedName };
      const rightImage = document.querySelector(`.${side}-side-container.right-side .side-image`) as HTMLImageElement;
      if (rightImage) {
        rightImage.src = imagePath;
        rightImage.style.display = 'block';
      }
    } else {
      resetSideSelection(side);
      fighters[side].main.image = imagePath;
      fighters[side].main.name = selectedName;
      const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
      if (mainImage) mainImage.src = imagePath;
    }

    updateButtonStates();
    fetchFighterInfo(side, imagePath);
  }
  
  // 檢查角色是否已被選擇
  function isCharacterSelected(side: 'left' | 'right', name: string | undefined): boolean {
    if (!name) return false;
    // 檢查所有已選擇的角色（包括兩邊）
    return fighters.left.main.name === name || 
           fighters.left.left?.name === name || 
           fighters.left.right?.name === name ||
           fighters.right.main.name === name || 
           fighters.right.left?.name === name || 
           fighters.right.right?.name === name;
  }

  // 重置一側的所有選擇
  function resetSideSelection(side: 'left' | 'right') {
    fighters[side].main = { image: null, totalPower: 0, name: null, physicPower: 0, magicPower: 0, utilityPower: 0, attributes: "" };
    fighters[side].left = undefined;
    fighters[side].right = undefined;

    const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
    const leftImage = document.querySelector(`.${side}-side-container.left-side .side-image`) as HTMLImageElement;
    const rightImage = document.querySelector(`.${side}-side-container.right-side .side-image`) as HTMLImageElement;

    if (mainImage) mainImage.src = config.defaultImage;
    if (leftImage) {
      leftImage.src = '';
      leftImage.style.display = 'none';
    }
    if (rightImage) {
      rightImage.src = '';
      rightImage.style.display = 'none';
    }

    // 清除 localStorage 數據
    clearLocalStorage(side);
  }
  
  // 更新按鈕狀態
  function updateButtonStates() {
    const selectedNames = new Set([
      fighters.left.main.name,
      fighters.left.left?.name,
      fighters.left.right?.name,
      fighters.right.main.name,
      fighters.right.left?.name,
      fighters.right.right?.name
    ].filter(Boolean));
    
    document.querySelectorAll("#leftButtons .button, #rightButtons .button").forEach(button => {
      button.classList.toggle("disabled", selectedNames.has(button.textContent));
    });
  }
  
  // 獲取角色資訊
  async function fetchFighterInfo(side: 'left' | 'right', imagePath: string) {
    try {
      const name = characterNames.find(n => n === imagePath.split("/").pop()?.split(".")[0]);
      const apiName = name;
      
      const token = await getValidToken();
      if (!token) {
        return;
      }
      
      // 獲取角色資訊
      const response = await fetch(config.apiEndpoint, {
        method: "POST",
        headers: { 
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
          "Accept": "application/json"
        },
        body: JSON.stringify({ name: apiName }),
        credentials: 'include'
      });
      
      if (!response.ok) {
        if (response.status === 401) {
          const newToken = await getValidToken();
          if (!newToken) {
            return;
          }
          return fetchFighterInfo(side, imagePath);
        }
        throw new Error(`API 返回錯誤: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data && data.name) {
        // 獲取武器資訊
        const weaponName = name?.toLowerCase() || '';
        const weaponResponse = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/weapons/${weaponName}`, {
          method: "GET",
          headers: { 
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`,
            "Accept": "application/json"
          },
          credentials: 'include'
        });

        if (weaponResponse.ok) {
          const weaponData = await weaponResponse.json();
          
          // 計算武器傷害
          let totalUtilityPower = parseInt(String(data.utilityPower || 0), 10);
          totalUtilityPower += parseInt(String(weaponData.baseDamage || 0), 10);

          // 檢查是否需要添加額外傷害
          if (weaponData.bonusAttributes && weaponData.bonusAttributes.includes(data.attributes)) {
            totalUtilityPower += parseInt(String(weaponData.bonusDamage || 0), 10);
          }

          // 更新數據中的 utilityPower
          data.utilityPower = totalUtilityPower;
        }

        updateFighterInfo(side, data);
        // 儲存到 localStorage
        saveToLocalStorage(side, data);
        return;
      }
      throw new Error("API 沒有返回有效數據");
    } catch (error) {
      console.error("獲取角色資訊失敗:", error);
      clearFighterInfo(side);
    }
  }
  
  // 更新角色資訊
  function updateFighterInfo(side: 'left' | 'right', fighter: any) {
    // 從 localStorage 獲取累加的值
    const storageKey = `fighters_${side}`;
    const storedData = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // 獲取當前顯示的角色列表
    const displayedCharacters = [];
    if (fighters[side].main.image) {
      const mainName = fighters[side].main.image.split("/").pop()?.split(".")[0];
      if (mainName) displayedCharacters.push(mainName);
    }
    if (fighters[side].left?.image) {
      const leftName = fighters[side].left.image.split("/").pop()?.split(".")[0];
      if (leftName) displayedCharacters.push(leftName);
    }
    if (fighters[side].right?.image) {
      const rightName = fighters[side].right.image.split("/").pop()?.split(".")[0];
      if (rightName) displayedCharacters.push(rightName);
    }

    // 使用 localStorage 中的值，如果沒有則使用當前角色的值
    const physicPower = storedData.physicPower || parseInt(String(fighter.physicPower || 0), 10);
    const magicPower = storedData.magicPower || parseInt(String(fighter.magicPower || 0), 10);
    const utilityPower = storedData.utilityPower || parseInt(String(fighter.utilityPower || 0), 10);
    const totalPower = physicPower + magicPower + utilityPower;
    
    // 顯示角色名稱，使用 localStorage 中的名稱列表
    const nameElement = document.getElementById(`${side}Name`);
    if (nameElement) {
      const names = storedData.nameOriginal || [];
      nameElement.textContent = names.join('、') || (fighter.nameOriginal || fighter.name) || "N/A";
    }
    
    const physicPowerElement = document.getElementById(`${side}PhysicPower`);
    const magicPowerElement = document.getElementById(`${side}MagicPower`);
    const utilityPowerElement = document.getElementById(`${side}UtilityPower`);
    
    if (physicPowerElement) physicPowerElement.textContent = `Physic Power: ${physicPower}`;
    if (magicPowerElement) magicPowerElement.textContent = `Magic Power: ${magicPower}`;
    if (utilityPowerElement) utilityPowerElement.textContent = `Utility Power: ${utilityPower}`;
    
    // 顯示屬性，使用 localStorage 中的屬性列表
    const attributesElement = document.getElementById(`${side}Attributes`);
    if (attributesElement) {
      const attributes = storedData.attributes || [];
      attributesElement.textContent = `Attributes: ${attributes.join('、') || (fighter.attributes || "N/A")}`;
    }
    
    // 顯示總力量
    const totalPowerElement = document.getElementById(`${side}TotalPower`);
    if (totalPowerElement) totalPowerElement.textContent = `Total Power: ${totalPower}`;
    
    // 確保存儲的總力量是數字
    fighters[side].main.totalPower = totalPower;
    fighters[side].main.nameOriginal = fighter.nameOriginal;
  }
  
  // 清除角色資訊
  function clearFighterInfo(side: 'left' | 'right') {
    const elements = [
      `${side}Name`,
      `${side}PhysicPower`,
      `${side}MagicPower`,
      `${side}UtilityPower`,
      `${side}Attributes`,
      `${side}TotalPower`
    ];
    
    elements.forEach(id => {
      const element = document.getElementById(id);
      if (element) element.textContent = "";
    });
    
    fighters[side].main.totalPower = 0;
    fighters[side].main.nameOriginal = undefined;
  }
  
  // 檢查並載入戰鬥版本的圖片
  async function loadFightingImage(side: 'left' | 'right', originalImagePath: string): Promise<string> {
    try {
      const originalName = originalImagePath.split("/").pop()?.split(".")[0];
      if (!originalName) return originalImagePath;

      const fightingImagePath = originalImagePath.replace(originalName, `${originalName}Fighting`);
      const response = await fetch(fightingImagePath);
      
      if (response.ok) {
        return fightingImagePath;
      }
    } catch (error) {
      console.error(`Error loading fighting image for ${side}:`, error);
    }
    return originalImagePath;
  }
  
  // 添加狀態效果
  function addStateEffect(side: 'left' | 'right', states: string[]) {
    const targetImage = document.getElementById(`${side}Image`) as HTMLImageElement;
    if (!targetImage) return;

    // 依次顯示每個狀態效果
    states.forEach((state, index) => {
      setTimeout(() => {
        const stateOverlay = document.createElement('div');
        stateOverlay.className = 'state-overlay';
        stateOverlay.textContent = state;
        targetImage.parentElement?.appendChild(stateOverlay);
        
        // 1秒後移除狀態效果
        setTimeout(() => {
          stateOverlay.remove();
        }, 1000);
      }, index * 1000); // 每個狀態效果間隔1秒
    });
  }

  // 開始戰鬥
  async function startFight() {
    const leftPower = parseInt(String(fighters.left.main.totalPower || 0), 10);
    const rightPower = parseInt(String(fighters.right.main.totalPower || 0), 10);
    
    const leftResult = document.getElementById("leftResult");
    const rightResult = document.getElementById("rightResult");
    const leftTotalPower = document.getElementById("leftTotalPower");
    const rightTotalPower = document.getElementById("rightTotalPower");
    
    // 重設樣式和文本
    if (leftResult) leftResult.textContent = "";
    if (rightResult) rightResult.textContent = "";
    if (leftTotalPower) leftTotalPower.classList.remove("win", "defeated");
    if (rightTotalPower) rightTotalPower.classList.remove("win", "defeated");
    
    // 如果任一方未選擇角色或力量為0，顯示提示
    if (!fighters.left.main.image || !fighters.right.main.image) {
      alert("請先選擇兩邊的角色");
      return;
    }

    // 載入戰鬥版本的圖片
    await loadFightingImages('left');
    await loadFightingImages('right');

    // 檢查並應用狀態效果
    try {
      const token = await getValidToken();
      if (token) {
        // 檢查左方角色的武器效果
        const leftName = fighters.left.main.name?.toLowerCase() || '';
        const leftWeaponResponse = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/weapons/${leftName}`, {
          method: "GET",
          headers: { 
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`,
            "Accept": "application/json"
          },
          credentials: 'include'
        });

        if (leftWeaponResponse.ok) {
          const leftWeaponData = await leftWeaponResponse.json();
          if (leftWeaponData.stateAttributes && Array.isArray(leftWeaponData.stateAttributes)) {
            addStateEffect('right', leftWeaponData.stateAttributes);
          }
        }

        // 檢查右方角色的武器效果
        const rightName = fighters.right.main.name?.toLowerCase() || '';
        const rightWeaponResponse = await fetch(`${import.meta.env.PUBLIC_TYMB_URL}/weapons/${rightName}`, {
          method: "GET",
          headers: { 
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`,
            "Accept": "application/json"
          },
          credentials: 'include'
        });

        if (rightWeaponResponse.ok) {
          const rightWeaponData = await rightWeaponResponse.json();
          if (rightWeaponData.stateAttributes && Array.isArray(rightWeaponData.stateAttributes)) {
            addStateEffect('left', rightWeaponData.stateAttributes);
          }
        }
      }
    } catch (error) {
      console.error("檢查武器狀態效果失敗:", error);
    }
    
    // 計算差距百分比
    const percentageDifference = Math.abs(leftPower - rightPower) / Math.max(leftPower, rightPower, 1);
    
    // 確定勝負
    if (leftPower > rightPower) {
      determineWinner("left", "right", leftPower, rightPower, percentageDifference);
    } else if (rightPower > leftPower) {
      determineWinner("right", "left", rightPower, leftPower, percentageDifference);
    } else {
      // 平局
      if (leftResult) leftResult.textContent = "Draw";
      if (rightResult) rightResult.textContent = "Draw";
      // 使用 nameOriginal 顯示角色名稱
      const leftName = document.getElementById("leftName");
      const rightName = document.getElementById("rightName");
      if (leftName) leftName.innerHTML = 
        `${fighters.left.main.nameOriginal || fighters.left.main.name}<br><span class='result'>draw</span>`;
      if (rightName) rightName.innerHTML = 
        `${fighters.right.main.nameOriginal || fighters.right.main.name}<br><span class='result'>draw</span>`;
    }
  }
  
  // 載入戰鬥版本的圖片
  async function loadFightingImages(side: 'left' | 'right') {
    const mainImage = document.getElementById(`${side}Image`) as HTMLImageElement;
    const leftImage = document.querySelector(`.${side}-side-container.left-side .side-image`) as HTMLImageElement;
    const rightImage = document.querySelector(`.${side}-side-container.right-side .side-image`) as HTMLImageElement;

    if (mainImage && fighters[side].main.image) {
      const mainFightingImage = await loadFightingImage(side, fighters[side].main.image);
      mainImage.src = mainFightingImage;
    }

    if (leftImage && fighters[side].left?.image) {
      const leftFightingImage = await loadFightingImage(side, fighters[side].left.image);
      leftImage.src = leftFightingImage;
    }

    if (rightImage && fighters[side].right?.image) {
      const rightFightingImage = await loadFightingImage(side, fighters[side].right.image);
      rightImage.src = rightFightingImage;
    }
  }
  
  // 確定勝負和結果顯示
  function determineWinner(winnerSide: 'left' | 'right', loserSide: 'left' | 'right', winnerPower: number, loserPower: number, difference: number) {
    const winnerElement = document.getElementById(`${winnerSide}TotalPower`);
    const loserElement = document.getElementById(`${loserSide}TotalPower`);
    const winnerResult = document.getElementById(`${winnerSide}Result`);
    const loserResult = document.getElementById(`${loserSide}Result`);
    const winnerName = document.getElementById(`${winnerSide}Name`);
    const loserName = document.getElementById(`${loserSide}Name`);
    const loserImage = document.getElementById(`${loserSide}Image`) as HTMLImageElement;
    const winnerImage = document.getElementById(`${winnerSide}Image`) as HTMLImageElement;
    
    // 重設樣式
    if (winnerElement) {
      winnerElement.classList.remove("defeated");
      winnerElement.classList.add("win");
      // 根據差距設置強度
      if (difference > 0.4) {
        winnerElement.setAttribute("data-intensity", "high");
      } else if (difference > 0.1) {
        winnerElement.setAttribute("data-intensity", "medium");
      } else {
        winnerElement.setAttribute("data-intensity", "low");
      }
    }
    if (loserElement) {
      loserElement.classList.remove("win");
      loserElement.classList.add("defeated");
      // 根據差距設置強度
      if (difference > 0.4) {
        loserElement.setAttribute("data-intensity", "high");
      } else if (difference > 0.1) {
        loserElement.setAttribute("data-intensity", "medium");
      } else {
        loserElement.setAttribute("data-intensity", "low");
      }
    }
    
    // 計算失敗百分比
    const lossPercentage = ((winnerPower - loserPower) / winnerPower * 100).toFixed(2);
    
    // 顯示基本結果
    if (winnerResult) winnerResult.textContent = "Winner";
    if (loserResult) loserResult.textContent = `${lossPercentage}% Defeated`;
    
    // 根據差距程度顯示不同結果和效果
    const winnerCharName = fighters[winnerSide].main.nameOriginal || fighters[winnerSide].main.name;
    const loserCharName = fighters[loserSide].main.nameOriginal || fighters[loserSide].main.name;
    
    // 添加疊加圖像
    const loserOverlay1 = document.getElementById(`${loserSide}Overlay1`) as HTMLImageElement;
    const loserOverlay2 = document.getElementById(`${loserSide}Overlay2`) as HTMLImageElement;
    const loserOverlay3 = document.getElementById(`${loserSide}Overlay3`) as HTMLImageElement;
    if (loserOverlay1 && loserOverlay2 && loserOverlay3) {
      // 先添加左側滑入的圖像
      loserOverlay2.classList.add('active', 'slide-in-left');
      
      // 延遲添加右側滑入的圖像
      setTimeout(() => {
        loserOverlay1.classList.add('active', 'slide-in-right');
      }, 250); // 延遲 250ms，讓第一張圖滑入一半時第二張圖開始滑入

      // 延遲添加第三張圖像（從後方縮放出現）
      setTimeout(() => {
        loserOverlay3.classList.add('active', 'scale-in');
      }, 500); // 延遲 500ms，讓前兩張圖完全滑入後再顯示第三張
    }
    
    if (difference > 0.4) {
      if (winnerName) {
        winnerName.innerHTML = `${winnerCharName}<br><span class='result' style='color: #00ff00; text-shadow: 0 0 8px rgba(0, 255, 0, 0.5); font-size: 18px; font-weight: bold;'>Destroying</span>`;
      }
      if (loserName) {
        loserName.innerHTML = `${loserCharName}<br><span class='result' style='color: #ff0000; text-shadow: 0 0 8px rgba(255, 0, 0, 0.5); font-size: 18px; font-weight: bold;'>Fucked Up</span>`;
      }
      if (loserImage) loserImage.classList.add('shake-extreme');
      if (winnerImage) winnerImage.classList.add('glow-extreme');
    } else if (difference > 0.1) {
      if (winnerName) {
        winnerName.innerHTML = `${winnerCharName}<br><span class='result' style='color: #00cc00; text-shadow: 0 0 6px rgba(0, 204, 0, 0.4); font-size: 18px; font-weight: bold;'>Destroying</span>`;
      }
      if (loserName) {
        loserName.innerHTML = `${loserCharName}<br><span class='result' style='color: #cc0000; text-shadow: 0 0 6px rgba(204, 0, 0, 0.4); font-size: 18px; font-weight: bold;'>Fucked Up</span>`;
      }
      if (loserImage) loserImage.classList.add('shake-hard');
      if (winnerImage) winnerImage.classList.add('glow-strong');
    } else {
      if (winnerName) {
        winnerName.innerHTML = `${winnerCharName}<br><span class='result' style='color: #009900; text-shadow: 0 0 4px rgba(0, 153, 0, 0.3); font-size: 18px; font-weight: bold;'>Destroying</span>`;
      }
      if (loserName) {
        loserName.innerHTML = `${loserCharName}<br><span class='result' style='color: #990000; text-shadow: 0 0 4px rgba(153, 0, 0, 0.3); font-size: 18px; font-weight: bold;'>Fucked Up</span>`;
      }
      if (loserImage) loserImage.classList.add('shake');
      if (winnerImage) winnerImage.classList.add('glow');
    }

    // 動畫結束後移除效果
    setTimeout(() => {
      if (loserImage) loserImage.classList.remove('shake', 'shake-hard', 'shake-extreme');
      if (winnerImage) winnerImage.classList.remove('glow', 'glow-strong', 'glow-extreme');
    }, 500);
  }
  
  // 頁面載入時初始化
  window.onload = () => {
    init();
    // 添加 Fight 按鈕的點擊事件監聽器
    const fightButton = document.getElementById('fightButton');
    if (fightButton) {
      fightButton.addEventListener('click', startFight);
    }
  };

  // 儲存到 localStorage
  function saveToLocalStorage(side: 'left' | 'right', fighter: any) {
    const storageKey = `fighters_${side}`;
    let currentData = JSON.parse(localStorage.getItem(storageKey) || '{}');
    
    // 初始化數據結構
    if (!currentData.physicPower) currentData.physicPower = 0;
    if (!currentData.magicPower) currentData.magicPower = 0;
    if (!currentData.utilityPower) currentData.utilityPower = 0;
    if (!currentData.nameOriginal) currentData.nameOriginal = [];
    if (!currentData.attributes) currentData.attributes = [];

    // 獲取當前選擇的角色名稱
    const currentName = fighter.nameOriginal || fighter.name;
    if (!currentName) return;

    // 檢查當前角色是否已經在列表中
    const isAlreadyAdded = currentData.nameOriginal.includes(currentName);
    
    // 如果角色已經存在，不重複添加
    if (!isAlreadyAdded) {
      // 累加數值
      currentData.physicPower += parseInt(String(fighter.physicPower || 0), 10);
      currentData.magicPower += parseInt(String(fighter.magicPower || 0), 10);
      currentData.utilityPower += parseInt(String(fighter.utilityPower || 0), 10);

      // 添加名稱和屬性
      currentData.nameOriginal.push(currentName);
      const attributes = fighter.attributes;
      if (attributes && !currentData.attributes.includes(attributes)) {
        currentData.attributes.push(attributes);
      }

      // 儲存回 localStorage
      localStorage.setItem(storageKey, JSON.stringify(currentData));

      // 輸出到控制台以便檢查
      console.log(`${side} side localStorage data:`, currentData);
      console.log(`Added character: ${currentName}`);

      // 立即更新顯示
      updateFighterInfo(side, currentData);
    } else {
      console.log(`Character ${currentName} already exists in localStorage`);
    }
  }

  // 清除 localStorage 數據
  function clearLocalStorage(side: 'left' | 'right') {
    localStorage.removeItem(`fighters_${side}`);
    console.log(`Cleared ${side} side localStorage data`);
  }
</script>

<script define:vars={{ characterNames }}>
  // 將角色名稱列表傳遞給客戶端腳本
  document.currentScript?.setAttribute('data-characters', JSON.stringify(characterNames));
</script>

