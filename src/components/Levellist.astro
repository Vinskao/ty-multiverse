---
import '../styles/levellist.css';

// 檢查登入狀態
const url = new URL(Astro.request.url);
const username = url.searchParams.get('username');
const token = url.searchParams.get('token');

// 如果未登入，重定向到首頁
if (!username || !token) {
  return Astro.redirect('/tymultiverse/');
}
---

<div id="power-list-container">
  <h2>力表</h2>
  <div id="power-list"></div>
</div>

<div id="level-container"></div>

<!-- 引入 SweetAlert2 -->
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<script>
  import { applyWeaponDamage, calculateWeaponDamage } from "../scripts/weapon";
  
  const TYMB_URL = import.meta.env.PUBLIC_TYMB_URL;
  const PEOPLE_IMAGE_URL = import.meta.env.PUBLIC_PEOPLE_IMAGE_URL;
  
  // 定義基本戰力等級
  const BASE_POWER_LEVELS = [
    { name: "Level S", min: 2600, max: 3599, color: "#FFD700" },
    { name: "Level A", min: 1600, max: 2599, color: "#00FF00" },
    { name: "Level B", min: 900, max: 1599, color: "#00FFFF" },
    { name: "Level C", min: 400, max: 899, color: "#0000FF" },
    { name: "Level D", min: 50, max: 399, color: "#800080" },
    { name: "Level F", min: 0, max: 49, color: "#808080" }
  ];

  // 定義軍隊顏色映射
  const ARMY_COLORS = {
    "八食": "#46A3FF",      
    "初桑": "#FFA500",      
    "Buse": "#AD5A5A",      
    "Phénix": "#FFFF00",    
    "姦閥": "#808080",      
    "姦囚": "#FFC0CB",      
    "Regalos": "#00FF00",   
    "天際女孩": "#00BFFF",  
    "外界": "#000080",      
    "王": "#FF0000",        
    "Intouchable": "#8B4513",
    "塵民": "#008080",      
    "獄族": "#800080",      
    "Default": "#FFFFFF"    
  };

  // 顯示提示訊息的函數
  function showAlert(title, icon = 'success', timer = 1000) {
    // 檢查 SweetAlert2 是否已載入
    if (typeof (window as any).Swal !== 'undefined') {
      (window as any).Swal.fire({
        title: title,
        icon: icon,
        timer: timer,
        showConfirmButton: false
      });
    } else {
      // 如果 SweetAlert2 未載入，使用原生 alert
      alert(title);
    }
  }

  // 刷新 token 的函數
  async function refreshToken() {
    try {
      const urlParams = new URLSearchParams(window.location.search);
      const refreshToken = urlParams.get('refresh_token');
      
      if (!refreshToken) {
        console.error('No refresh token available');
        if (typeof (window as any).Swal !== 'undefined') {
          (window as any).Swal.fire({
            title: '無法獲取有效的 token',
            icon: 'error',
            timer: 0,
            showConfirmButton: true
          });
        }
        window.location.href = '/tymultiverse/login';
        return false;
      }

      const response = await fetch(`${TYMB_URL}/keycloak/refresh`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Accept": "application/json"
        },
        body: JSON.stringify({ refresh_token: refreshToken }),
        credentials: 'include'
      });

      if (!response.ok) {
        console.error('Token refresh failed:', response.status);
        window.location.href = '/tymultiverse/login';
        return false;
      }

      const data = await response.json();
      if (data.token) {
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.set('token', data.token);
        if (data.refresh_token) {
          currentUrl.searchParams.set('refresh_token', data.refresh_token);
        }
        window.history.replaceState({}, '', currentUrl.toString());
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error refreshing token:', error);
      window.location.href = '/tymultiverse/login';
      return false;
    }
  }

  // 驗證 token 是否有效
  async function verifyToken(token) {
    try {
      const response = await fetch(`${TYMB_URL}/keycloak/introspect?token=${token}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json',
        },
        credentials: 'include'
      });

      if (response.ok) {
        const data = await response.json();
        return data.active;
      }
      return false;
    } catch (error) {
      console.error('Token verification failed:', error);
      return false;
    }
  }

  // 獲取有效的 token
  async function getValidToken() {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    
    if (!token) {
      console.error('No token available');
      if (typeof (window as any).Swal !== 'undefined') {
        (window as any).Swal.fire({
          title: '無法獲取有效的 token',
          icon: 'error',
          timer: 0,
          showConfirmButton: true
        });
      }
      window.location.href = '/tymultiverse/login';
      return null;
    }

    const isValid = await verifyToken(token);
    if (isValid) {
      return token;
    }

    const refreshed = await refreshToken();
    if (!refreshed) {
      return null;
    }

    const newUrlParams = new URLSearchParams(window.location.search);
    return newUrlParams.get('token');
  }

  // 檢查圖片是否存在
  async function checkImageExists(imagePath) {
    try {
      const response = await fetch(imagePath);
      return response.ok;
    } catch {
      return false;
    }
  }

  // 創建角色卡片
  function createCharacterCard(character, levelColor) {
    const characterContainer = document.createElement('div');
    characterContainer.style.cssText = 'display:inline-block;height:300px;text-align:center;position:relative;z-index:1;';

    const img = document.createElement('img');
    img.style.cssText = 'height:300px;display:block;object-fit:contain;margin:0 auto;padding:0;border:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:2;transition:opacity 0.5s ease-in-out;';
    img.src = `${PEOPLE_IMAGE_URL}/${character.name || 'default'}.png`;
    img.alt = character.nameOriginal;
    img.onerror = function() {
      this.src = `${PEOPLE_IMAGE_URL}/default.png`;
    };

    // 圖片加載完成後設置容器寬度
    img.onload = function() {
      const imgElement = this as HTMLImageElement;
      const aspectRatio = imgElement.naturalWidth / imgElement.naturalHeight;
      const containerWidth = 300 * aspectRatio;
      characterContainer.style.width = `${containerWidth}px`;
      characterContainer.style.marginLeft = `-${containerWidth/2}px`;
    };

    // 檢查戰鬥圖片
    checkImageExists(`${PEOPLE_IMAGE_URL}/${character.name || 'default'}Fighting.png`).then(hasFightingImage => {
      if (hasFightingImage) {
        const fightingImg = document.createElement('img');
        fightingImg.style.cssText = img.style.cssText + 'opacity:0;';
        fightingImg.src = `${PEOPLE_IMAGE_URL}/${character.name || 'default'}Fighting.png`;
        fightingImg.alt = `${character.nameOriginal} Fighting`;
        
        // 戰鬥圖片加載完成後也設置容器寬度
        fightingImg.onload = function() {
          const imgElement = this as HTMLImageElement;
          const aspectRatio = imgElement.naturalWidth / imgElement.naturalHeight;
          const containerWidth = 300 * aspectRatio;
          characterContainer.style.width = `${containerWidth}px`;
          characterContainer.style.marginLeft = `-${containerWidth/2}px`;
        };
        
        characterContainer.appendChild(fightingImg);

        let isRegularImage = true;
        setInterval(() => {
          img.style.opacity = isRegularImage ? '0' : '1';
          fightingImg.style.opacity = isRegularImage ? '1' : '0';
          isRegularImage = !isRegularImage;
        }, 2000);
      }
    });

    // 添加懸停事件
    img.addEventListener('mouseover', () => {
      (img as HTMLImageElement).style.zIndex = '3';
      if (img.nextElementSibling?.tagName === 'IMG') {
        (img.nextElementSibling as HTMLImageElement).style.zIndex = '3';
      }
    });
    img.addEventListener('mouseout', () => {
      (img as HTMLImageElement).style.zIndex = '2';
      if (img.nextElementSibling?.tagName === 'IMG') {
        (img.nextElementSibling as HTMLImageElement).style.zIndex = '2';
      }
    });

    // 創建信息容器
    const infoContainer = document.createElement('div');
    infoContainer.style.cssText = 'padding:5px;color:#fff;text-shadow:0 0 2px rgba(0,0,0,0.5);width:200px;position:absolute;bottom:-40px;left:0;overflow:hidden;font-size:12px;z-index:4;background-color:transparent;border-radius:5px;';

    // 添加名稱
    const nameText = document.createElement('p');
    nameText.textContent = character.nameOriginal;
    nameText.style.cssText = 'margin:0;font-weight:bold;font-size:clamp(12px,1.2vw,14px);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;';
    const armyName = character.armyName || "Default";
    nameText.style.color = ARMY_COLORS[armyName] || ARMY_COLORS["Default"];
    nameText.style.textShadow = '0 0 2px rgba(0,0,0,0.5)';

    // 添加屬性
    const attributesText = document.createElement('p');
    attributesText.textContent = `Attributes: ${character.attributes}`;
    attributesText.style.cssText = 'margin:0;font-size:clamp(6px,0.8vw,8px);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;';
    if (character.hasBonus) {
      const bonusBadge = document.createElement('span');
      bonusBadge.textContent = '⚔️';
      bonusBadge.style.cssText = 'margin-left:5px;font-size:clamp(6px,0.8vw,8px);';
      attributesText.appendChild(bonusBadge);
    }

    // 添加戰力
    const powerText = document.createElement('p');
    powerText.textContent = `Total Power: ${character.totalPower}`;
    powerText.style.cssText = 'margin:0;font-size:clamp(12px,0.8vw,14px);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;';
    powerText.style.color = levelColor;

    infoContainer.appendChild(nameText);
    infoContainer.appendChild(attributesText);
    infoContainer.appendChild(powerText);
    characterContainer.appendChild(img);
    characterContainer.appendChild(infoContainer);
    return characterContainer;
  }

  // 創建等級容器
  function createLevelContainer(level, characters) {
    const levelContainer = document.createElement('div');
    levelContainer.className = 'level-container';
    levelContainer.style.marginTop = '50px';
    levelContainer.style.borderColor = level.color;

    const levelTitle = document.createElement('h2');
    levelTitle.className = 'level-title';
    levelTitle.textContent = level.name;
    levelTitle.style.marginBottom = '15px';
    levelTitle.style.color = level.color;

    const levelBadge = document.createElement('div');
    levelBadge.className = 'level-badge';
    levelBadge.style.backgroundColor = level.color;
    levelBadge.style.width = '100%';
    levelBadge.style.textAlign = 'center';
    levelBadge.textContent = `戰力: ${level.min} - ${level.max}`;
    levelBadge.style.color = level.color.includes('rgb') ? '#FFFFFF' : 
      (parseInt(level.color.substr(1, 2), 16) * 299 + 
       parseInt(level.color.substr(3, 2), 16) * 587 + 
       parseInt(level.color.substr(5, 2), 16) * 114) / 1000 > 128 ? '#000000' : '#FFFFFF';

    const charactersGrid = document.createElement('div');
    charactersGrid.className = 'box-container';
    charactersGrid.style.margin = '0 auto';

    characters.forEach(character => {
      charactersGrid.appendChild(createCharacterCard(character, level.color));
    });

    levelContainer.appendChild(levelTitle);
    levelContainer.appendChild(levelBadge);
    levelContainer.appendChild(charactersGrid);
    return levelContainer;
  }

  // 創建戰力列表
  function createPowerList(characters) {
    const powerListContainer = document.getElementById('power-list');
    if (!powerListContainer) return;
    
    // 創建一個可滾動的容器
    const scrollContainer = document.createElement('div');
    scrollContainer.style.width = '100%';
    scrollContainer.style.overflowX = 'auto';
    scrollContainer.style.marginBottom = '20px';
    scrollContainer.style.position = 'relative'; // 添加相對定位
    scrollContainer.style.maxWidth = '100%'; // 確保容器不會超出父元素
    
    // 創建表格
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    table.style.minWidth = '800px'; // 確保表格有最小寬度
    table.style.tableLayout = 'fixed'; // 使用固定表格布局
    table.style.fontSize = '12px'; // 字體小一點
    
    // 創建表頭
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    const headers = ['角色名稱', '物理戰力', '魔法戰力', '武器戰力', '武器加成', '總戰力', '操作'];
    headers.forEach(headerText => {
      const th = document.createElement('th');
      th.textContent = headerText;
      th.style.padding = '4px'; // 上下間距密集一點
      th.style.border = '1px solid #ddd';
      th.style.backgroundColor = '#f2f2f2';
      th.style.textAlign = 'left';
      th.style.whiteSpace = 'nowrap'; // 防止表頭換行
      th.style.overflow = 'hidden'; // 防止內容溢出
      th.style.textOverflow = 'ellipsis'; // 超出顯示省略號
      th.style.color = '#FF4500'; // 表頭字體顏色設為鮮豔的橙紅色
      th.style.fontWeight = 'bold'; // 表頭字體加粗
      th.style.fontSize = '14px'; // 表頭字體稍大
      th.style.textShadow = '0 0 1px rgba(0,0,0,0.3)'; // 添加文字陰影增加對比度
      headerRow.appendChild(th);
    });
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // 創建表格內容
    const tbody = document.createElement('tbody');
    
    // 按總戰力排序
    const sortedCharacters = [...characters].sort((a, b) => b.totalPower - a.totalPower);
    
    // 創建一個 Map 來存儲每個角色的當前戰力值
    const characterPowerMap = new Map();
    
    sortedCharacters.forEach(character => {
      const row = document.createElement('tr');
      
      // 角色名稱
      const nameCell = document.createElement('td');
      nameCell.textContent = character.nameOriginal || character.name || 'Unknown';
      nameCell.style.padding = '4px'; // 上下間距密集一點
      nameCell.style.border = '1px solid #ddd';
      nameCell.style.whiteSpace = 'nowrap'; // 防止文字換行
      nameCell.style.overflow = 'hidden'; // 防止內容溢出
      nameCell.style.textOverflow = 'ellipsis'; // 超出顯示省略號
      row.appendChild(nameCell);
      
      // 物理戰力
      const physicCell = document.createElement('td');
      const physicInput = document.createElement('input');
      physicInput.type = 'number';
      physicInput.value = character.physicPower || '0';
      physicInput.style.width = '50px'; // 寬度小一點
      physicInput.style.padding = '2px'; // 上下間距密集一點
      physicInput.dataset.originalValue = character.physicPower || '0';
      physicCell.appendChild(physicInput);
      physicCell.style.padding = '4px'; // 上下間距密集一點
      physicCell.style.border = '1px solid #ddd';
      row.appendChild(physicCell);
      
      // 魔法戰力
      const magicCell = document.createElement('td');
      const magicInput = document.createElement('input');
      magicInput.type = 'number';
      magicInput.value = character.magicPower || '0';
      magicInput.style.width = '50px'; // 寬度小一點
      magicInput.style.padding = '2px'; // 上下間距密集一點
      magicInput.dataset.originalValue = character.magicPower || '0';
      magicCell.appendChild(magicInput);
      magicCell.style.padding = '4px'; // 上下間距密集一點
      magicCell.style.border = '1px solid #ddd';
      row.appendChild(magicCell);
      
      // 武器戰力 (可編輯)
      const utilityCell = document.createElement('td');
      const utilityInput = document.createElement('input');
      utilityInput.type = 'number';
      utilityInput.value = character.originalUtilityPower || '0';
      utilityInput.style.width = '50px'; // 寬度小一點
      utilityInput.style.padding = '2px'; // 上下間距密集一點
      utilityInput.dataset.originalValue = character.originalUtilityPower || '0';
      utilityCell.appendChild(utilityInput);
      utilityCell.style.padding = '4px'; // 上下間距密集一點
      utilityCell.style.border = '1px solid #ddd';
      row.appendChild(utilityCell);
      
      // 武器加成 (不可編輯，顯示武器加成值)
      const totalUtilityCell = document.createElement('td');
      // 顯示武器加成值
      totalUtilityCell.textContent = character.hasBonus ? 
        `${character.weaponBonus || '0'} ⚔️` : 
        '0';
      totalUtilityCell.style.padding = '4px'; // 上下間距密集一點
      totalUtilityCell.style.border = '1px solid #ddd';
      totalUtilityCell.style.whiteSpace = 'nowrap'; // 防止文字換行
      totalUtilityCell.style.overflow = 'hidden'; // 防止內容溢出
      totalUtilityCell.style.textOverflow = 'ellipsis'; // 超出顯示省略號
      row.appendChild(totalUtilityCell);
      
      // 總戰力
      const totalCell = document.createElement('td');
      totalCell.textContent = character.totalPower || '0';
      totalCell.style.padding = '4px'; // 上下間距密集一點
      totalCell.style.border = '1px solid #ddd';
      totalCell.style.fontWeight = 'bold';
      totalCell.style.whiteSpace = 'nowrap'; // 防止文字換行
      totalCell.style.overflow = 'hidden'; // 防止內容溢出
      totalCell.style.textOverflow = 'ellipsis'; // 超出顯示省略號
      row.appendChild(totalCell);
      
      // 操作按鈕
      const actionCell = document.createElement('td');
      actionCell.style.padding = '4px'; // 上下間距密集一點
      actionCell.style.border = '1px solid #ddd';
      actionCell.style.whiteSpace = 'nowrap'; // 防止文字換行
      
      const updateButton = document.createElement('button');
      updateButton.textContent = '更新';
      updateButton.style.cssText = `
        padding: 4px 8px;
        background: linear-gradient(145deg, #4CAF50, #45a049);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      `;
      
      // 添加懸停效果
      updateButton.addEventListener('mouseover', () => {
        updateButton.style.background = 'linear-gradient(145deg, #45a049, #4CAF50)';
        updateButton.style.transform = 'translateY(-1px)';
        updateButton.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
      });
      
      updateButton.addEventListener('mouseout', () => {
        updateButton.style.background = 'linear-gradient(145deg, #4CAF50, #45a049)';
        updateButton.style.transform = 'translateY(0)';
        updateButton.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
      });
      
      // 儲存原始值
      const originalData = {
        id: character.id || 0,
        name: character.name || '',
        baseAttributes: character.baseAttributes || '',
        bonusAttributes: character.bonusAttributes || '',
        stateAttributes: character.stateAttributes || '',
        nameOriginal: character.nameOriginal || '',
        codeName: character.codeName || '',
        physicPower: character.physicPower || 0,
        magicPower: character.magicPower || 0,
        utilityPower: character.utilityPower || 0,
        dob: character.dob || '',
        race: character.race || '',
        attributes: character.attributes || '',
        gender: character.gender || '',
        assSize: character.assSize || '',
        boobsSize: character.boobsSize || '',
        heightCm: character.heightCm || 0,
        weightKg: character.weightKg || 0,
        profession: character.profession || '',
        combat: character.combat || '',
        favoriteFoods: character.favoriteFoods || '',
        job: character.job || '',
        physics: character.physics || '',
        knownAs: character.knownAs || '',
        personally: character.personally || '',
        interest: character.interest || '',
        likes: character.likes || '',
        dislikes: character.dislikes || '',
        concubine: character.concubine || '',
        faction: character.faction || '',
        armyId: character.armyId || 0,
        armyName: character.armyName || '',
        deptId: character.deptId || 0,
        deptName: character.deptName || '',
        originArmyId: character.originArmyId || 0,
        originArmyName: character.originArmyName || '',
        gaveBirth: character.gaveBirth || false,
        email: character.email || '',
        age: character.age || 0,
        proxy: character.proxy || '',
        hei: character.hei || '',
        physicsFallout4: character.physicsFallout4 || '',
        version: character.version || 0,
        hrratio: character.hrratio || '',
        hasBonus: character.hasBonus || false,
        weaponBonus: character.weaponBonus || 0
      };
      
      // 初始化角色戰力映射
      characterPowerMap.set(character.name, {
        physicPower: character.physicPower || 0,
        magicPower: character.magicPower || 0,
        utilityPower: character.originalUtilityPower || 0,
        weaponBonus: character.weaponBonus || 0,
        hasBonus: character.hasBonus || false,
        totalPower: character.totalPower || 0,
        attributes: character.attributes || '',
        weaponData: character.weaponData || null
      });
      
      // 添加輸入事件監聽器，實現動態計算總戰力
      const updateTotalPower = async () => {
        const currentData = characterPowerMap.get(character.name);
        const physicPower = parseInt(physicInput.value) || 0;
        const magicPower = parseInt(magicInput.value) || 0;
        const utilityPower = parseInt(utilityInput.value) || 0;
        
        // 更新映射中的值
        currentData.physicPower = physicPower;
        currentData.magicPower = magicPower;
        currentData.utilityPower = utilityPower;
        
        // 計算武器加成
        let weaponBonus = 0;
        let hasBonus = false;
        
        // 檢查角色是否有武器加成
        if (currentData.hasBonus && currentData.weaponData) {
          try {
            // 使用 weapon.js 中的邏輯計算武器加成
            const { totalDamage, hasBonus: bonusApplied } = calculateWeaponDamage(
              { 
                utilityPower: utilityPower,
                attributes: currentData.attributes
              }, 
              currentData.weaponData ? [currentData.weaponData] : []
            );
            
            weaponBonus = totalDamage;
            hasBonus = bonusApplied;
            
            // 更新映射中的武器加成值
            currentData.weaponBonus = weaponBonus;
            currentData.hasBonus = hasBonus;
            
            // 更新武器加成顯示
            totalUtilityCell.textContent = hasBonus ? 
              `${weaponBonus} ⚔️` : 
              '0';
          } catch (error) {
            console.error(`計算武器加成時出錯: ${error.message}`);
            // 如果計算出錯，使用原始值
            weaponBonus = currentData.weaponBonus || 0;
            hasBonus = currentData.hasBonus || false;
          }
        }
        
        // 計算新的總戰力
        const newTotalPower = physicPower + magicPower + utilityPower + weaponBonus;
        currentData.totalPower = newTotalPower;
        
        // 更新總戰力顯示
        totalCell.textContent = String(newTotalPower);
        
        // 將更新後的數據保存到 localStorage
        saveToLocalStorage(character.name, currentData);
      };
      
      // 為每個輸入框添加事件監聽器
      physicInput.addEventListener('input', updateTotalPower);
      magicInput.addEventListener('input', updateTotalPower);
      utilityInput.addEventListener('input', updateTotalPower);
      
      // 更新按鈕點擊事件
      updateButton.addEventListener('click', async () => {
        try {
          const token = await getValidToken();
          if (!token) {
            if (typeof (window as any).Swal !== 'undefined') {
              (window as any).Swal.fire({
                title: '無法獲取有效的 token',
                icon: 'error',
                timer: 0,
                showConfirmButton: true
              });
            }
            return;
          }
          
          // 獲取當前輸入值
          const currentData = {
            id: 0, // 直接設置 ID 為 0
            name: character.name || '',
            baseAttributes: character.baseAttributes || '',
            bonusAttributes: character.bonusAttributes || '',
            stateAttributes: character.stateAttributes || '',
            nameOriginal: character.nameOriginal || '',
            codeName: character.codeName || '',
            physicPower: parseInt(physicInput.value) || 0,
            magicPower: parseInt(magicInput.value) || 0,
            utilityPower: parseInt(utilityInput.value) || 0,
            dob: character.dob || '',
            race: character.race || '',
            attributes: character.attributes || '',
            gender: character.gender || '',
            assSize: character.assSize || '',
            boobsSize: character.boobsSize || '',
            heightCm: character.heightCm || 0,
            weightKg: character.weightKg || 0,
            profession: character.profession || '',
            combat: character.combat || '',
            favoriteFoods: character.favoriteFoods || '',
            job: character.job || '',
            physics: character.physics || '',
            knownAs: character.knownAs || '',
            personally: character.personally || '',
            interest: character.interest || '',
            likes: character.likes || '',
            dislikes: character.dislikes || '',
            concubine: character.concubine || '',
            faction: character.faction || '',
            armyId: character.armyId || 0,
            armyName: character.armyName || '',
            deptId: character.deptId || 0,
            deptName: character.deptName || '',
            originArmyId: character.originArmyId || 0,
            originArmyName: character.originArmyName || '',
            gaveBirth: character.gaveBirth || false,
            email: character.email || '',
            age: character.age || 0,
            proxy: character.proxy || '',
            hei: character.hei || '',
            physicsFallout4: character.physicsFallout4 || '',
            version: character.version || 1, // 確保 version 不為 null
            hrratio: character.hrratio || ''
          };
          
          // 發送更新請求
          const response = await fetch(`${TYMB_URL}/people/update`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`,
              'Accept': 'application/json'
            },
            body: JSON.stringify(currentData),
            credentials: 'include'
          });
          
          if (!response.ok) {
            throw new Error(`更新失敗: ${response.status}`);
          }
          
          const result = await response.json();
          
          // 使用 SweetAlert2 顯示成功訊息
          if (typeof (window as any).Swal !== 'undefined') {
            (window as any).Swal.fire({
              title: '更新成功！',
              icon: 'success',
              timer: 1500,
              showConfirmButton: false
            });
          }
          
          // 更新原始值
          originalData.physicPower = currentData.physicPower;
          originalData.magicPower = currentData.magicPower;
          originalData.utilityPower = currentData.utilityPower;
          
          // 更新輸入框的原始值
          physicInput.dataset.originalValue = String(currentData.physicPower);
          magicInput.dataset.originalValue = String(currentData.magicPower);
          utilityInput.dataset.originalValue = String(currentData.utilityPower);
          
        } catch (error) {
          console.error('更新角色能力時出錯:', error);
          if (typeof (window as any).Swal !== 'undefined') {
            (window as any).Swal.fire({
              title: '更新失敗: ' + error.message,
              icon: 'error',
              timer: 0,
              showConfirmButton: true
            });
          }
        }
      });
      
      actionCell.appendChild(updateButton);
      row.appendChild(actionCell);
      
      tbody.appendChild(row);
    });
    
    table.appendChild(tbody);
    scrollContainer.appendChild(table);
    powerListContainer.appendChild(scrollContainer);
  }

  // 保存到 localStorage
  function saveToLocalStorage(characterName, data) {
    try {
      // 獲取現有的暫存數據
      const storageKey = 'character_power_cache';
      let cachedData = JSON.parse(localStorage.getItem(storageKey) || '{}');
      
      // 更新特定角色的數據
      cachedData[characterName] = data;
      
      // 保存回 localStorage
      localStorage.setItem(storageKey, JSON.stringify(cachedData));
      
      console.log(`已暫存 ${characterName} 的戰力數據`);
    } catch (error) {
      console.error('暫存戰力數據時出錯:', error);
    }
  }

  // 從 localStorage 獲取暫存數據
  function getFromLocalStorage(characterName) {
    try {
      const storageKey = 'character_power_cache';
      const cachedData = JSON.parse(localStorage.getItem(storageKey) || '{}');
      return cachedData[characterName] || null;
    } catch (error) {
      console.error('獲取暫存戰力數據時出錯:', error);
      return null;
    }
  }

  // 主函數
  document.addEventListener("DOMContentLoaded", async function () {
    try {
      const token = await getValidToken();
      if (!token) return;

      const response = await fetch(`${TYMB_URL}/people/get-all`, {
        method: "POST", 
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
          "Accept": "application/json"
        },
        credentials: 'include'
      });
      
      if (!response.ok) throw new Error('Failed to fetch character list');
      
      const data = await response.json();
      
      // 計算每個角色的總戰力並獲取武器資訊
      const charactersWithPower = await Promise.all(
        data.map(async (character) => {
          try {
            // 檢查是否有暫存的戰力數據
            const cachedData = getFromLocalStorage(character.name);
            if (cachedData) {
              console.log(`使用暫存的戰力數據: ${character.name}`);
              return {
                ...character,
                totalPower: cachedData.totalPower,
                physicPower: cachedData.physicPower,
                magicPower: cachedData.magicPower,
                utilityPower: cachedData.utilityPower + (cachedData.hasBonus ? cachedData.weaponBonus : 0),
                originalUtilityPower: cachedData.utilityPower,
                weaponBonus: cachedData.weaponBonus,
                hasBonus: cachedData.hasBonus,
                weaponData: cachedData.weaponData
              };
            }
            
            // 保存原始武器戰力值
            const originalUtilityPower = parseInt(String(character.utilityPower || 0), 10);
            let totalUtilityPower = originalUtilityPower;
            let hasBonus = false;
            let weaponBonus = 0;
            let weaponData: any = null;
            
            // 獲取角色的所有武器
            const weaponName = character.name?.toLowerCase() || '';
            const weaponResponse = await fetch(`${TYMB_URL}/weapons/${weaponName}`, {
              method: "GET",
              headers: { 
                "Content-Type": "application/json",
                "Authorization": `Bearer ${token}`,
                "Accept": "application/json"
              },
              credentials: 'include'
            });
            
            if (weaponResponse.ok) {
              // 獲取所有武器數據
              const weaponsData = await weaponResponse.json();
              
              // 確保 weaponsData 是數組
              const weaponsArray = Array.isArray(weaponsData) ? weaponsData : [weaponsData];
              
              // 使用所有武器計算加成
              const { character: updatedCharacter, hasBonus: bonusApplied } = applyWeaponDamage(character, weaponsArray);
              totalUtilityPower = updatedCharacter.utilityPower;
              hasBonus = bonusApplied;
              
              // 計算武器加成值
              if (hasBonus) {
                weaponBonus = totalUtilityPower - originalUtilityPower;
              }
              
              // 保存所有武器數據
              weaponData = weaponsArray;
            }

            const physicPower = parseInt(String(character?.physicPower || 0), 10);
            const magicPower = parseInt(String(character?.magicPower || 0), 10);
            const totalPower = physicPower + magicPower + totalUtilityPower;

            return {
              ...character,
              totalPower,
              physicPower,
              magicPower,
              utilityPower: totalUtilityPower,
              originalUtilityPower, // 保存原始武器戰力值
              weaponBonus, // 保存武器加成值
              hasBonus,
              weaponData // 保存武器數據
            };
          } catch (error) {
            console.error(`Error fetching weapon info for ${character.name}:`, error);
            const originalUtilityPower = parseInt(String(character.utilityPower || 0), 10);
            return {
              ...character,
              totalPower: parseInt(String(character.physicPower || 0), 10) + 
                          parseInt(String(character.magicPower || 0), 10) + 
                          parseInt(String(character.utilityPower || 0), 10),
              physicPower: parseInt(String(character.physicPower || 0), 10),
              magicPower: parseInt(String(character.magicPower || 0), 10),
              utilityPower: parseInt(String(character.utilityPower || 0), 10),
              originalUtilityPower, // 保存原始武器戰力值
              weaponBonus: 0, // 無武器加成
              hasBonus: false,
              weaponData: null
            };
          }
        })
      );

      // 過濾掉戰力為0的角色和沒有圖片的角色
      const validCharacters = await Promise.all(
        charactersWithPower.filter(char => char.totalPower > 0).map(async (character) => {
          const imagePath = `${PEOPLE_IMAGE_URL}/${character.name || 'default'}.png`;
          const hasImage = await checkImageExists(imagePath);
          return hasImage ? character : null;
        })
      );
      
      const filteredCharacters = validCharacters.filter(char => char !== null);
      filteredCharacters.sort((a, b) => b.totalPower - a.totalPower);

      // 創建戰力列表
      createPowerList(charactersWithPower);

      // 動態生成SS及以上等級
      const POWER_LEVELS = [...BASE_POWER_LEVELS];
      const maxPower = filteredCharacters.length > 0 ? filteredCharacters[0].totalPower : 0;
      let currentMin = 3600;
      let levelIndex = 1;
      let multiplier = 1.0;
      
      while (currentMin <= maxPower) {
        multiplier *= 1.2;
        const levelSize = Math.floor(1000 * multiplier);
        const levelMax = currentMin + levelSize - 1;
        const levelName = "Level " + "S".repeat(levelIndex + 1);
        const redValue = Math.max(50, 255 - (levelIndex * 20));
        const color = `rgb(${redValue}, 0, 0)`;
        
        POWER_LEVELS.unshift({
          name: levelName,
          min: currentMin,
          max: levelMax,
          color: color
        });
        
        currentMin = levelMax + 1;
        levelIndex++;
      }

      // 將角色分配到各個等級
      const levelGroups = {};
      POWER_LEVELS.forEach(level => {
        levelGroups[level.name] = [];
      });

      filteredCharacters.forEach(character => {
        for (let i = 0; i < POWER_LEVELS.length; i++) {
          if (character.totalPower >= POWER_LEVELS[i].min && character.totalPower <= POWER_LEVELS[i].max) {
            levelGroups[POWER_LEVELS[i].name].push(character);
            break;
          }
        }
      });

      // 創建 UI
      const mainContainer = document.createElement('div');
      mainContainer.className = 'level-groups';

      // 從低到高顯示等級，跳過沒有角色的等級
      POWER_LEVELS.reverse().forEach(level => {
        const characters = levelGroups[level.name];
        if (characters.length === 0) return;
        mainContainer.appendChild(createLevelContainer(level, characters));
      });

      const container = document.getElementById('level-container');
      if (container) {
        container.appendChild(mainContainer);
      }
    } catch (error) {
      console.error('Error:', error);
    }
  });
</script>
