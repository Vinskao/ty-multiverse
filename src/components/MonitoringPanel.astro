---
// ç›£æ§é¢æ¿çµ„ä»¶
---

<div id="monitoring-panel" class="monitoring-panel">
  <div class="panel-header">
    <h3>ğŸ”§ ç³»çµ±ç›£æ§é¢æ¿</h3>
    <div class="panel-controls">
      <button id="refresh-btn" class="btn btn-primary">åˆ·æ–°</button>
      <button id="export-btn" class="btn btn-secondary">å°å‡ºè¨ºæ–·</button>
      <button id="clear-btn" class="btn btn-danger">æ¸…é™¤çµ±è¨ˆ</button>
    </div>
  </div>

  <div class="panel-content">
    <!-- ç³»çµ±å¥åº·ç‹€æ³ -->
    <div class="section">
      <h4>ğŸ¥ ç³»çµ±å¥åº·ç‹€æ³</h4>
      <div id="health-status" class="health-grid">
        <div class="loading">è¼‰å…¥ä¸­...</div>
      </div>
    </div>

    <!-- Consumer ç‹€æ…‹ -->
    <div class="section">
      <h4>ğŸ”„ Consumer ç‹€æ…‹</h4>
      <div id="consumer-status" class="status-card">
        <div class="loading">è¼‰å…¥ä¸­...</div>
      </div>
    </div>

    <!-- API æŒ‡æ¨™ -->
    <div class="section">
      <h4>ğŸ“Š API æŒ‡æ¨™</h4>
      <div id="api-metrics" class="metrics-grid">
        <div class="loading">è¼‰å…¥ä¸­...</div>
      </div>
    </div>

    <!-- éŒ¯èª¤çµ±è¨ˆ -->
    <div class="section">
      <h4>ğŸš¨ éŒ¯èª¤çµ±è¨ˆ</h4>
      <div id="error-stats" class="error-grid">
        <div class="loading">è¼‰å…¥ä¸­...</div>
      </div>
    </div>

    <!-- é‡è©¦çµ±è¨ˆ -->
    <div class="section">
      <h4>ğŸ”„ é‡è©¦çµ±è¨ˆ</h4>
      <div id="retry-stats" class="retry-grid">
        <div class="loading">è¼‰å…¥ä¸­...</div>
      </div>
    </div>
  </div>
</div>

<style>
  .monitoring-panel {
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 20px;
    margin: 20px 0;
    font-family: 'Courier New', monospace;
  }

  .panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid #333;
  }

  .panel-header h3 {
    margin: 0;
    color: #fff;
  }

  .panel-controls {
    display: flex;
    gap: 10px;
  }

  .btn {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s;
  }

  .btn-primary {
    background: #007bff;
    color: white;
  }

  .btn-secondary {
    background: #6c757d;
    color: white;
  }

  .btn-danger {
    background: #dc3545;
    color: white;
  }

  .btn:hover {
    opacity: 0.8;
  }

  .section {
    margin-bottom: 25px;
  }

  .section h4 {
    margin: 0 0 15px 0;
    color: #fff;
    font-size: 16px;
  }

  .health-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
  }

  .health-item {
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 15px;
    text-align: center;
  }

  .health-item.healthy {
    border-color: #28a745;
  }

  .health-item.warning {
    border-color: #ffc107;
  }

  .health-item.critical {
    border-color: #dc3545;
  }

  .health-item h5 {
    margin: 0 0 10px 0;
    color: #fff;
    font-size: 14px;
  }

  .health-item .status {
    font-size: 24px;
    margin-bottom: 5px;
  }

  .health-item .message {
    font-size: 12px;
    color: #ccc;
  }

  .status-card {
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 15px;
  }

  .status-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
  }

  .status-row:last-child {
    margin-bottom: 0;
  }

  .status-label {
    color: #ccc;
    font-size: 12px;
  }

  .status-value {
    color: #fff;
    font-size: 12px;
    font-weight: bold;
  }

  .metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
  }

  .metric-card {
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 15px;
  }

  .metric-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }

  .metric-name {
    color: #fff;
    font-size: 14px;
    font-weight: bold;
  }

  .metric-status {
    font-size: 12px;
    padding: 2px 8px;
    border-radius: 12px;
  }

  .metric-status.success {
    background: #28a745;
    color: white;
  }

  .metric-status.error {
    background: #dc3545;
    color: white;
  }

  .metric-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    font-size: 11px;
  }

  .metric-stat {
    display: flex;
    justify-content: space-between;
  }

  .metric-label {
    color: #ccc;
  }

  .metric-value {
    color: #fff;
    font-weight: bold;
  }

  .error-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
  }

  .error-item {
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 10px;
    text-align: center;
  }

  .error-type {
    color: #fff;
    font-size: 12px;
    margin-bottom: 5px;
  }

  .error-count {
    color: #dc3545;
    font-size: 18px;
    font-weight: bold;
  }

  .retry-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
  }

  .retry-item {
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 15px;
  }

  .retry-name {
    color: #fff;
    font-size: 14px;
    margin-bottom: 10px;
  }

  .retry-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    font-size: 11px;
  }

  .loading {
    color: #ccc;
    text-align: center;
    padding: 20px;
    font-style: italic;
  }

  .timestamp {
    color: #666;
    font-size: 10px;
    text-align: right;
    margin-top: 10px;
  }
</style>

<script>
  class MonitoringPanel {
    private serviceManager: any;
    private refreshInterval?: number;

    constructor() {
      this.initialize();
    }

    private async initializeServiceManager() {
      const ServiceManager = (await import('../services/core/serviceManager')).default;
      this.serviceManager = ServiceManager.getInstance();
    }

    private async initialize(): Promise<void> {
      await this.initializeServiceManager();
      this.setupEventListeners();
      this.startAutoRefresh();
      this.refreshData();
    }

    private setupEventListeners(): void {
      const refreshBtn = document.getElementById('refresh-btn');
      const exportBtn = document.getElementById('export-btn');
      const clearBtn = document.getElementById('clear-btn');

      refreshBtn?.addEventListener('click', () => this.refreshData());
      exportBtn?.addEventListener('click', () => this.exportDiagnostics());
      clearBtn?.addEventListener('click', () => this.clearStats());
    }

    private startAutoRefresh(): void {
      this.refreshInterval = window.setInterval(() => {
        this.refreshData();
      }, 30000); // æ¯30ç§’åˆ·æ–°ä¸€æ¬¡
    }

    private async refreshData(): Promise<void> {
      try {
        await Promise.all([
          this.updateHealthStatus(),
          this.updateConsumerStatus(),
          this.updateAPIMetrics(),
          this.updateErrorStats(),
          this.updateRetryStats()
        ]);
      } catch (error) {
        console.error('åˆ·æ–°ç›£æ§æ•¸æ“šå¤±æ•—:', error);
      }
    }

    private async updateHealthStatus(): Promise<void> {
      const healthElement = document.getElementById('health-status');
      if (!healthElement) return;

      try {
        const health = await this.serviceManager.getSystemHealth();
        
        healthElement.innerHTML = `
          <div class="health-item ${health.overallHealth}">
            <h5>æ•´é«”å¥åº·ç‹€æ³</h5>
            <div class="status">${this.getHealthIcon(health.overallHealth)}</div>
            <div class="message">${health.overallHealth.toUpperCase()}</div>
          </div>
          <div class="health-item ${health.consumerStatus.isConnected ? 'healthy' : 'critical'}">
            <h5>Consumer é€£æ¥</h5>
            <div class="status">${health.consumerStatus.isConnected ? 'âœ…' : 'âŒ'}</div>
            <div class="message">${health.consumerStatus.isConnected ? 'å·²é€£æ¥' : 'æœªé€£æ¥'}</div>
          </div>
          <div class="health-item ${this.getMemoryHealthClass(health.memoryUsage)}">
            <h5>å…§å­˜ä½¿ç”¨</h5>
            <div class="status">${(health.memoryUsage * 100).toFixed(1)}%</div>
            <div class="message">${this.getMemoryHealthMessage(health.memoryUsage)}</div>
          </div>
          <div class="health-item ${this.getErrorHealthClass(health.errorRate)}">
            <h5>éŒ¯èª¤ç‡</h5>
            <div class="status">${(health.errorRate * 100).toFixed(2)}%</div>
            <div class="message">${this.getErrorHealthMessage(health.errorRate)}</div>
          </div>
        `;
      } catch (error) {
        healthElement.innerHTML = '<div class="loading">è¼‰å…¥å¤±æ•—</div>';
      }
    }

    private async updateConsumerStatus(): Promise<void> {
      const consumerElement = document.getElementById('consumer-status');
      if (!consumerElement) return;

      try {
        const status = this.serviceManager.getConsumerStatus();
        
        consumerElement.innerHTML = `
          <div class="status-row">
            <span class="status-label">é€£æ¥ç‹€æ…‹:</span>
            <span class="status-value">${status.isConnected ? 'âœ… å·²é€£æ¥' : 'âŒ æœªé€£æ¥'}</span>
          </div>
          <div class="status-row">
            <span class="status-label">æœ€å¾Œå¿ƒè·³:</span>
            <span class="status-value">${new Date(status.lastHeartbeat).toLocaleTimeString()}</span>
          </div>
          <div class="status-row">
            <span class="status-label">éšŠåˆ—å¤§å°:</span>
            <span class="status-value">${status.queueSize}</span>
          </div>
          <div class="status-row">
            <span class="status-label">è™•ç†é€Ÿç‡:</span>
            <span class="status-value">${status.processingRate}/ç§’</span>
          </div>
          <div class="status-row">
            <span class="status-label">éŒ¯èª¤ç‡:</span>
            <span class="status-value">${(status.errorRate * 100).toFixed(2)}%</span>
          </div>
          <div class="status-row">
            <span class="status-label">é‹è¡Œæ™‚é–“:</span>
            <span class="status-value">${this.formatUptime(status.uptime)}</span>
          </div>
        `;
      } catch (error) {
        consumerElement.innerHTML = '<div class="loading">è¼‰å…¥å¤±æ•—</div>';
      }
    }

    private async updateAPIMetrics(): Promise<void> {
      const metricsElement = document.getElementById('api-metrics');
      if (!metricsElement) return;

      try {
        const metrics = this.serviceManager.getAPIMetrics() as Map<string, any>;
        
        if (metrics.size === 0) {
          metricsElement.innerHTML = '<div class="loading">æš«ç„¡ API æŒ‡æ¨™æ•¸æ“š</div>';
          return;
        }

        const metricsHTML = Array.from(metrics.entries()).map(([endpoint, metric]) => `
          <div class="metric-card">
            <div class="metric-header">
              <span class="metric-name">${endpoint}</span>
              <span class="metric-status ${metric.errorCount === 0 ? 'success' : 'error'}">
                ${metric.errorCount === 0 ? 'æ­£å¸¸' : 'éŒ¯èª¤'}
              </span>
            </div>
            <div class="metric-stats">
              <div class="metric-stat">
                <span class="metric-label">è«‹æ±‚æ•¸:</span>
                <span class="metric-value">${metric.requestCount}</span>
              </div>
              <div class="metric-stat">
                <span class="metric-label">æˆåŠŸç‡:</span>
                <span class="metric-value">${((metric.successCount / metric.requestCount) * 100).toFixed(1)}%</span>
              </div>
              <div class="metric-stat">
                <span class="metric-label">å¹³å‡éŸ¿æ‡‰:</span>
                <span class="metric-value">${metric.averageResponseTime.toFixed(0)}ms</span>
              </div>
              <div class="metric-stat">
                <span class="metric-label">æœ€å¾Œè«‹æ±‚:</span>
                <span class="metric-value">${new Date(metric.lastRequestTime).toLocaleTimeString()}</span>
              </div>
            </div>
          </div>
        `).join('');

        metricsElement.innerHTML = metricsHTML;
      } catch (error) {
        metricsElement.innerHTML = '<div class="loading">è¼‰å…¥å¤±æ•—</div>';
      }
    }

    private async updateErrorStats(): Promise<void> {
      const errorElement = document.getElementById('error-stats');
      if (!errorElement) return;

      try {
        const errorStats = this.serviceManager.getErrorStats();
        
        const errorHTML = Object.entries(errorStats).map(([type, count]) => `
          <div class="error-item">
            <div class="error-type">${this.getErrorTypeLabel(type)}</div>
            <div class="error-count">${count}</div>
          </div>
        `).join('');

        errorElement.innerHTML = errorHTML || '<div class="loading">æš«ç„¡éŒ¯èª¤æ•¸æ“š</div>';
      } catch (error) {
        errorElement.innerHTML = '<div class="loading">è¼‰å…¥å¤±æ•—</div>';
      }
    }

    private async updateRetryStats(): Promise<void> {
      const retryElement = document.getElementById('retry-stats');
      if (!retryElement) return;

      try {
        const retryStats = this.serviceManager.getRetryStats() as Map<string, any>;
        
        if (retryStats.size === 0) {
          retryElement.innerHTML = '<div class="loading">æš«ç„¡é‡è©¦æ•¸æ“š</div>';
          return;
        }

        const retryHTML = Array.from(retryStats.entries()).map(([operation, stats]) => `
          <div class="retry-item">
            <div class="retry-name">${operation}</div>
            <div class="retry-stats">
              <div class="metric-stat">
                <span class="metric-label">ç¸½å˜—è©¦:</span>
                <span class="metric-value">${stats.totalAttempts}</span>
              </div>
              <div class="metric-stat">
                <span class="metric-label">æˆåŠŸ:</span>
                <span class="metric-value">${stats.successfulAttempts}</span>
              </div>
              <div class="metric-stat">
                <span class="metric-label">å¤±æ•—:</span>
                <span class="metric-value">${stats.failedAttempts}</span>
              </div>
              <div class="metric-stat">
                <span class="metric-label">å¹³å‡éŸ¿æ‡‰:</span>
                <span class="metric-value">${stats.averageResponseTime.toFixed(0)}ms</span>
              </div>
            </div>
          </div>
        `).join('');

        retryElement.innerHTML = retryHTML;
      } catch (error) {
        retryElement.innerHTML = '<div class="loading">è¼‰å…¥å¤±æ•—</div>';
      }
    }

    private exportDiagnostics(): void {
      try {
        const diagnostics = this.serviceManager.exportDiagnostics();
        const blob = new Blob([diagnostics], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `diagnostics-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('å°å‡ºè¨ºæ–·ä¿¡æ¯å¤±æ•—:', error);
        alert('å°å‡ºå¤±æ•—');
      }
    }

    private clearStats(): void {
      if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰çµ±è¨ˆæ•¸æ“šå—ï¼Ÿ')) {
        this.serviceManager.clearAllStats();
        this.refreshData();
      }
    }

    private getHealthIcon(health: string): string {
      switch (health) {
        case 'healthy': return 'âœ…';
        case 'warning': return 'âš ï¸';
        case 'critical': return 'ğŸš¨';
        default: return 'â“';
      }
    }

    private getMemoryHealthClass(usage: number): string {
      if (usage < 0.7) return 'healthy';
      if (usage < 0.9) return 'warning';
      return 'critical';
    }

    private getMemoryHealthMessage(usage: number): string {
      if (usage < 0.7) return 'æ­£å¸¸';
      if (usage < 0.9) return 'è¼ƒé«˜';
      return 'éé«˜';
    }

    private getErrorHealthClass(rate: number): string {
      if (rate < 0.05) return 'healthy';
      if (rate < 0.1) return 'warning';
      return 'critical';
    }

    private getErrorHealthMessage(rate: number): string {
      if (rate < 0.05) return 'æ­£å¸¸';
      if (rate < 0.1) return 'è¼ƒé«˜';
      return 'éé«˜';
    }

    private getErrorTypeLabel(type: string): string {
      const labels: Record<string, string> = {
        'NETWORK': 'ç¶²çµ¡éŒ¯èª¤',
        'AUTHENTICATION': 'èªè­‰éŒ¯èª¤',
        'AUTHORIZATION': 'æˆæ¬ŠéŒ¯èª¤',
        'VALIDATION': 'é©—è­‰éŒ¯èª¤',
        'SERVER': 'æœå‹™å™¨éŒ¯èª¤',
        'TIMEOUT': 'è¶…æ™‚éŒ¯èª¤',
        'RATE_LIMIT': 'é€Ÿç‡é™åˆ¶',
        'UNKNOWN': 'æœªçŸ¥éŒ¯èª¤'
      };
      return labels[type] || type;
    }

    private formatUptime(seconds: number): string {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      return `${hours}h ${minutes}m ${secs}s`;
    }

    destroy(): void {
      if (this.refreshInterval) {
        clearInterval(this.refreshInterval);
      }
    }
  }

  // åˆå§‹åŒ–ç›£æ§é¢æ¿
  document.addEventListener('DOMContentLoaded', () => {
    new MonitoringPanel();
  });
</script>
